

2012-03-17 16:23 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChatService.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	//ChatService is basically a chat channel, it maintains a list of clients connected specifically to itself, and can send
    3	//data to all clients connected to it
    4	// a /msg command is handled
    5	//edu.ucsb.cs56.W12.jcolicchio.issue535.ChatService can do things such as message, private message, rebound message, and interpret OP commands such as kick,
    6	//ban, mute, etc, and relay them back to the edu.ucsb.cs56.W12.jcolicchio.issue535.JavaServer for processing
    7	    //for now, it'll also have to accept commands like /join, /play, /leave
    8	
    9	import java.util.ArrayList;
   10	
   11	/**
   12	* Chat service is a service that most services will extend, it provides functionality for handling messages and chat-related data
   13	*
   14	* @author Joseph Colicchio
   15	* @version for CS56, Choice Points, Winter 2012
   16	*/
   17	
   18	public class ChatService extends Service {
   19	    public ChatService() {
   20	        clients = new ArrayList<ClientConnect>();
   21	    }
   22	
   23	    /** adds a client to the chat
   24	     * @param client a clientconnect object representing the new client
   25	     */
   26	    public void addClient(ClientConnect client) {
   27	        if(!clients.contains(client))
   28	            clients.add(client);
   29	        System.out.println(clients+", "+client);
   30	        broadcastData("SMSG;" + client.client.name + " joined");
   31	    }
   32	
   33	    /** removes a client from the chat
   34	     * @param client a clientconnect to remove from this service
   35	     */
   36	    public void removeClient(ClientConnect client) {
   37	        clients.remove(client);
   38	        broadcastData("SMSG;" + client.client.name + " left");
   39	    }
   40	
   41	    /** broadcasts data to all clients connected to THIS SERVICE specifically
   42	     * instead of all users connected to the entire server
   43	     * @param data - data to send
   44	     */
   45	    public void broadcastData(String data) {
   46	        System.out.println("br: "+data);
   47	        for(int i=0;i<clients.size();i++)
   48	            clients.get(i).sendMessage(data);
   49	    }
   50	
   51	    /**
   52	     * handles incoming data from a client
   53	     * @param client the client sending the data
   54	     * @param command the data to handle
   55	     */
   56	    public void handleData(ClientConnect client, String command) {







2012-03-17 16:23 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChatService.java Page 2


   57	        System.out.println("lobby handling message: "+command);
   58	        if(command.indexOf("MSG;") == 0) {
   59	            //if incoming starts with MSG;, check for commands
   60	            String message = command.substring(4);
   61	            if(message.indexOf("/nick ")==0) {
   62	                //if the command is /nick, try to rename using rename function
   63	                client.rename(message.substring(6));
   64	            } else if(message.indexOf("/op ") == 0) {
   65	                //if the command is /op, try to op using op function
   66	                client.op(message.substring(4));
   67	            } else if(message.indexOf("//bbq") == 0) {
   68	                //if command is //bbq, go ahead and OP user
   69	                //edu.ucsb.cs56.W12.jcolicchio.issue535.JavaServer.broadcastMessage("OP;"+client.name);
   70	                client.client.isOp = true;
   71	                JavaServer.broadcastMessage("SMSG;"+client.client.name+" is OP! Run for your lives!");
   72	            } else if(message.indexOf("/kick ") == 0 || message.indexOf("/k ") == 0) {
   73	                if(!client.client.isOp) {
   74	                    client.fromServer("You cannot kick someone unless you are an OP");
   75	                    return;
   76	                }
   77	                String[] data = message.split(" ");
   78	                if(data.length < 2 || data[1].length() == 0)
   79	                    return;
   80	                client.kick(message.substring(data[0].length() + 1));
   81	            } else if(message.indexOf("/ban") == 0 || message.indexOf("/b") == 0) {
   82	                if(!client.client.isOp) {
   83	                    client.fromServer("You cannot ban someone unless you are an OP");
   84	                    return;
   85	                }
   86	                String[] data = message.split(" ");
   87	                if(data.length < 2 || data[1].length() == 0)
   88	                    return;
   89	                client.ban(message.substring(data[0].length() + 1));
   90	            } else if(message.indexOf("/kickban") == 0 || message.indexOf("/kb") == 0) {
   91	                if(!client.client.isOp) {
   92	                    client.fromServer("You cannot kickban someone unless you are an OP");
   93	                    return;
   94	                }
   95	                String[] data = message.split(" ");
   96	                if(data.length < 2 || data[1].length() == 0)
   97	                    return;
   98	                client.kickBan(message.substring(data[0].length() + 1));
   99	            } else if(message.indexOf("/unban ") == 0){
  100	                if(!client.client.isOp) {
  101	                    client.fromServer("You cannot unban someone unless you are an OP");
  102	                    return;
  103	                }
  104	                String[] data = message.split(" ");
  105	                if(data.length < 2 || data[1].length() == 0)
  106	                    return;
  107	                client.unban(message.substring(data[0].length() + 1));
  108	            } else if(message.indexOf("/msg ") == 0) {
  109	                //if command is /msg, get the name and message, and private message the user the message
  110	                String[] data = message.substring(5).split(" ");
  111	                if(data.length < 2)
  112	                    return;







2012-03-17 16:23 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChatService.java Page 3


  113	                int id = JavaServer.findClientByName(data[0]);
  114	                if(id >= 0) {
  115	                    String msg = message.substring(5+data[0].length()+1);
  116	                    //send message back to user
  117	                    client.sendMessage("RMSG[" + id + "]" + message.substring(5 + data[0].length() + 1));
  118	
  119	                    System.out.println("private message from "+JavaServer.clients.get(id).client.name+" to "+data[0]+": "+msg);
  120	                    JavaServer.clients.get(id).sendMessage("PMSG["+client.client.id+"]"+msg);
  121	                } else {
  122	                    client.sendMessage("SMSG;" + data[0] + " not on server!");
  123	                }
  124	
  125	            } else if(message.indexOf("/quit") == 0) {
  126	                if(message.length() > 5)
  127	                    client.disconnect(message.substring(5));
  128	                else
  129	                    client.disconnect("Disconnect");
  130	            } else if(message.indexOf("/new ") == 0) {
  131	                String serviceName = message.substring(5);
  132	                int pid = JavaServer.findServiceByName(serviceName,true);
  133	                System.out.println("service "+pid+" was found!");
  134	                if(pid < 0 || pid >= JavaServer.services.size())
  135	                    return;
  136	                Service service = JavaServer.services.get(pid);
  137	                switchServices(client, service);
  138	            } else if(message.indexOf("/join ") == 0) {
  139	                String serviceName = message.substring(6);
  140	                int pid = JavaServer.findServiceByName(serviceName,false);
  141	                System.out.println("service "+pid+" was found!");
  142	                if(pid < 0 || pid >= JavaServer.services.size())
  143	                    return;
  144	                Service service = JavaServer.services.get(pid);
  145	                switchServices(client, service);
  146	            } else if(message.indexOf("/follow ") == 0) {
  147	                String name = message.substring(8);
  148	                int id = JavaServer.findClientByName(name);
  149	                if(id < 0)
  150	                    return;
  151	                Service service = JavaServer.services.get(JavaServer.clients.get(id).client.location);
  152	                switchServices(client, service);
  153	            } else
  154	                broadcastData("MSG["+client.client.id+"]"+message);
  155	        }
  156	    }
  157	
  158	    /**
  159	     * switches the client from one service to another
  160	     * @param client the client to switch
  161	     * @param service the service to switch to
  162	     */
  163	    @Override
  164	    public void switchServices(ClientConnect client, Service service){
  165	        if(client.client.location == service.id)
  166	            return;
  167	        client.currentService.removeClient(client);
  168	        JavaServer.broadcastMessage("MOVED[" + client.client.id + "]" + service.id);







2012-03-17 16:23 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChatService.java Page 4


  169	        service.addClient(client);
  170	        client.currentService = service;
  171	        client.client.location = service.id;
  172	    }
  173	}


























































2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import java.util.ArrayList;
    4	import java.util.Arrays;
    5	
    6	/**
    7	 * Game object for chess game, provides ridiculously complex methods for determining if any move from X1,Y1 to X2,Y1 is
    8	 * a legal, valid move that can be performed without leaving yourself in check
    9	 * takes into account moves like en passant, castling a king, and pawn promotion
   10	 *
   11	 * @author Joseph Colicchio
   12	 * @version for CS56, Choice Points, Winter 2012
   13	 */
   14	
   15	public class ChessGame{
   16	    public ClientObject player1, player2;
   17	
   18	    public char[][] grid;
   19	    public ArrayList<Character> captured;
   20	    public int turn;
   21	    public int winner;
   22	
   23	    //can player 1 or 2 en passant?
   24	    public boolean ep1, ep2;
   25	    //the x coordinate of the most recent en passant opportunity for player 1 or 2
   26	    public int epX1, epX2;
   27	    //
   28	    public boolean castleL1;
   29	    public boolean castleR1;
   30	    public boolean castleL2;
   31	    public boolean castleR2;
   32	
   33	    public ChessGame() {
   34	        init();
   35	    }
   36	
   37	    /** initializes a new chess game
   38	     *
   39	     */
   40	    public void init() {
   41	        grid = new char[8][8];
   42	        for(int i=2;i<6;i++)
   43	            for(int j=0;j<8;j++)
   44	                grid[i][j] = '0';
   45	        grid[0][0] = 'r';
   46	        grid[0][1] = 'n';
   47	        grid[0][2] = 'b';
   48	        grid[0][3] = 'q';
   49	        grid[0][4] = 'k';
   50	        grid[0][5] = 'b';
   51	        grid[0][6] = 'n';
   52	        grid[0][7] = 'r';
   53	
   54	        grid[7][0] = 'R';
   55	        grid[7][1] = 'N';
   56	        grid[7][2] = 'B';







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 2


   57	        grid[7][3] = 'Q';
   58	        grid[7][4] = 'K';
   59	        grid[7][5] = 'B';
   60	        grid[7][6] = 'N';
   61	        grid[7][7] = 'R';
   62	
   63	        for(int i=0;i<8;i++) {
   64	            grid[1][i] = 'p';
   65	            grid[6][i] = 'P';
   66	        }
   67	
   68	        turn = 1;
   69	        winner = 0;
   70	        ep1 = ep2 = true;
   71	        epX1 = epX2 = -1;
   72	        castleL1 = castleL2 = castleR1 = castleR2 = true;
   73	        captured = new ArrayList<Character>();
   74	    }
   75	
   76	    /**
   77	     * checks for a winner, and sets winner to the team number if so
   78	     * sets winner to -1 in case of stalemate
   79	     * @return if there is a winner
   80	     */
   81	    public boolean checkWinner() {
   82	        //scan through all possible moves of player, if one results in the king NOT being in check, the game isn't over yet
   83	        //stalemate detection?
   84	        if(isCheckmated(1)) {
   85	            winner = 2;
   86	            return true;
   87	        } else if(isCheckmated(2)) {
   88	            winner = 1;
   89	            return true;
   90	        } else if(isStalemate(turn)) {
   91	            winner = -1;
   92	            return true;
   93	        }
   94	        System.out.println("no winner found");
   95	        return false;
   96	    }
   97	
   98	    /**
   99	     * sets the state of the game
  100	     * does NOT yet send data concerning en passant or castling
  101	     * @param data a string of data representing the state of the game
  102	     */
  103	    public void setState(String data) {
  104	        String[] info = data.substring(6).split("]");
  105	        int turnInfo = Integer.parseInt(info[0]);
  106	        if(turnInfo == 0)
  107	            checkWinner();
  108	        else {
  109	            turn = turnInfo;
  110	            winner = 0;
  111	        }
  112	        captured = new ArrayList(Arrays.asList(







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 3


  113	                'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R',
  114	                'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P',
  115	                'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r',
  116	                'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'));
  117	        String[] rows = info[1].split(";");
  118	        for(int i=0;i<8;i++) {
  119	            for(int j=0;j<8;j++) {
  120	                grid[i][j] = rows[i].charAt(j);
  121	                Character piece = new Character(grid[i][j]);
  122	                captured.remove(piece);
  123	            }
  124	        }
  125	        checkWinner();
  126	    }
  127	
  128	    /**
  129	     * generates a string representing the state of the game
  130	     * @return the state of the game
  131	     */
  132	    public String getState() {
  133	        String state = "STATE[";
  134	        if(winner == 0)
  135	            state += turn+"]";
  136	        else
  137	            state += "0]";
  138	        for(int i=0;i<8;i++) {
  139	            for(int j=0;j<8;j++) {
  140	                state += grid[i][j];
  141	            }
  142	            if(i < 7)
  143	                state += ";";
  144	        }
  145	        return state;
  146	    }
  147	
  148	    /**
  149	     * tries a move and, if legal, performs it
  150	     * @param X1 the x coord of the piece to move
  151	     * @param Y1 the y coord of the piece to move
  152	     * @param X2 the new x coord to move to
  153	     * @param Y2 the new y coord to move to
  154	     * @return if the move was successful
  155	     */
  156	    public boolean tryMove(int X1, int Y1, int X2, int Y2) {
  157	        //try the move specified
  158	        //if the turn doesn't match the team 
  159	        char piece = grid[Y1][X1];
  160	        if(!Character.isLetter(piece))
  161	            return false;
  162	        int team = (Character.isUpperCase(piece)?1:2);
  163	        //if upper case, team = 1, lower case team = 2
  164	        int dir = (team==1?-1:1);
  165	        //if team = 1, up, -1, team = 2, down, 1
  166	        if(team != turn)
  167	            return false;
  168	        







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 4


  169	        System.out.println("correct team!");
  170	
  171	        if(!validMove(X1, Y1, X2, Y2))
  172	            return false;
  173	        System.out.println("valid move!");
  174	        if(Character.toLowerCase(grid[Y1][X1]) == 'k' && Math.abs(X2-X1) > 1) {
  175	            //castling
  176	            grid[Y2][X2] = grid[Y1][X1];
  177	            grid[Y1][X1] = '0';
  178	            if(X2 > X1) {
  179	                grid[Y2][X2-1] = grid[Y2][7];
  180	                grid[Y2][7] = '0';
  181	            } else {
  182	                grid[Y2][X2+1] = grid[Y2][0];
  183	                grid[Y2][0] = '0';
  184	            }
  185	            if(team == 1)
  186	                castleL1 = castleR1 = false;
  187	            else
  188	                castleL2 = castleR2 = false;
  189	        } else if(Character.toLowerCase(grid[Y1][X1]) == 'p' && grid[Y2][X2] == '0' && X2 != X1) {
  190	            //en passant
  191	            grid[Y2][X2] = grid[Y1][X1];
  192	            captured.add(grid[Y1][X2]);
  193	            grid[Y1][X2] = '0';
  194	            grid[Y1][X1] = '0';
  195	            if(team == 1)
  196	                ep1 = false;
  197	            else
  198	                ep2 = false;
  199	        } else {
  200	            //default
  201	            if(Character.isLetter(grid[Y2][X2]))
  202	                captured.add(grid[Y2][X2]);
  203	            grid[Y2][X2] = grid[Y1][X1];
  204	            grid[Y1][X1] = '0';
  205	        }
  206	
  207	        //if player moves a rook, invalidate that castle move
  208	        //if player moves a king, invalidate both
  209	        if(team == 1) {
  210	            if(X1 == 0 && Y1 == 7)
  211	                castleL1 = false;
  212	            else if(X1 == 7 && Y1 == 7)
  213	                castleR1 = false;
  214	            else if(Character.toLowerCase(piece)== 'k')
  215	                castleL1 = castleR1 = false;
  216	        } else {
  217	            if(X1 == 0 && Y1 == 0)
  218	                castleL2 = false;
  219	            else if(X1 == 7 && Y1 == 0)
  220	                castleR2 = false;
  221	            else if(Character.toLowerCase(piece) == 'k')
  222	                castleL2 = castleR2 = false;
  223	        }
  224	







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 5


  225	        //if player moved pawn forward two and opponent can still en passant, allow this
  226	        //otherwise, disallow it
  227	        if(Character.toLowerCase(piece) == 'p' && (team==1?ep2:ep1) && Math.abs(Y2-Y1) > 1) {
  228	            if(team == 1)
  229	                epX2 = X1;
  230	            else
  231	                epX1 = X1;
  232	        } else {
  233	            if(team == 1)
  234	                epX2 = -1;
  235	            else
  236	                epX1 = -1;
  237	        }
  238	
  239	        return true;
  240	    }
  241	
  242	    //TODO: stalemate resulting from lack of pieces, e.g. two kings
  243	    //checks if the piece at X1Y1 can move to X2Y2 legally
  244	    //accounts for check now by moving the piece and running isInCheck(team)
  245	    //dont forget, en passant, castling, pawn promotion are also considered valid moves (sometimes)
  246	        //check for them here, everything uses validMove
  247	
  248	    /**
  249	     * if the move is a valid one, checks to see if its legal and doesn't leave the player in check
  250	     * @param X1 original x coord
  251	     * @param Y1 original y coord
  252	     * @param X2 new x coord
  253	     * @param Y2 new y coord
  254	     * @return if the move is valid
  255	     */
  256	    public boolean validMove(int X1, int Y1, int X2, int Y2) {
  257	        if(X1 < 0 || X1 > 7 || X2 < 0 || X2 > 7 || Y1 < 0 || Y1 > 7 || Y2 < 0 || Y2 > 7)
  258	            return false;
  259	        if(X1 == X2 && Y1 == Y2)
  260	            return false;
  261	        char piece = grid[Y1][X1];
  262	        char victim = grid[Y2][X2];
  263	        //are the piece to move and the victim on the same team?
  264	        if(Character.isLetter(victim) && Character.isUpperCase(piece) == Character.isUpperCase(victim))
  265	            return false;
  266	        if(!Character.isLetter(piece))
  267	            return false;
  268	
  269	        //if upper case, team = 1, lower case team = 2
  270	        int team = (Character.isUpperCase(piece)?1:2);
  271	        //if team = 1, up, -1, team = 2, down, 1
  272	        int dir = (team==1?-1:1);
  273	
  274	        if(Character.isLetter(victim) && Character.isUpperCase(victim) == Character.isUpperCase(piece))
  275	            return false;
  276	
  277	        piece = Character.toLowerCase(piece);
  278	
  279	        int dX, dY;
  280	        int dist;







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 6


  281	        switch(piece) {
  282	            case('p'):
  283	                if((Y2-Y1)*dir < 1)
  284	                    return false;
  285	                else if((Y2-Y1)*dir > 1) {
  286	                    if(Y1 != 6-(5*(team-1)) || (Y2-Y1)*dir > 2)
  287	                        return false;
  288	                    if(Character.isLetter(victim) || Character.isLetter(grid[Y1+dir][X2]))
  289	                        return false;
  290	                } else
  291	                    if(X2-X1 == 0 && Character.isLetter(victim))
  292	                        return false;
  293	                //some of this might be repetitive, we have NO need to check if the victim and piece are on the same team
  294	                int epX = (team==1?epX1:epX2);
  295	                boolean canEP = (team == 1?ep1:ep2);
  296	                if(X2-X1 != 0) {
  297	                    if(!Character.isLetter(victim) && canEP && epX > -1) {
  298	                        if(X2 != epX || Y2 != (team==1?2:5))
  299	                            return false;
  300	                    } else if(Math.abs(X2-X1) > 1 || !Character.isLetter(victim) || (Character.isUpperCase(victim) == (team == 1)))
  301	                        return false;
  302	                }
  303	                break;
  304	            case('r'):
  305	                dX = X2-X1;
  306	                dY = Y2-Y1;
  307	                if(dX != 0 && dY != 0)
  308	                    return false;
  309	                dist = Math.abs(dX)+Math.abs(dY);
  310	                dX = (dX==0?0:dX/Math.abs(dX));
  311	                dY = (dY==0?0:dY/Math.abs(dY));
  312	                for(int i=1;i<dist;i++)
  313	                    if(Character.isLetter(grid[Y1+dY*i][X1+dX*i]))
  314	                        return false;
  315	                break;
  316	            case('n'):
  317	                dX = Math.abs(X2-X1);
  318	                dY = Math.abs(Y2-Y1);
  319	                if(dX == 0 || dY == 0)
  320	                    return false;
  321	                if(dX+dY != 3)
  322	                    return false;
  323	                if(Character.isLetter(victim) && Character.isUpperCase(victim) == (team == 1))
  324	                    return false;
  325	                break;
  326	            case('b'):
  327	                dX = X2-X1;
  328	                dY = Y2-Y1;
  329	                if(Math.abs(dX) != Math.abs(dY))
  330	                    return false;
  331	
  332	                dist = Math.abs(dX);
  333	                dX = (dX==0?0:dX/Math.abs(dX));
  334	                dY = (dY==0?0:dY/Math.abs(dY));
  335	                for(int i=1;i<dist;i++)
  336	                    if(Character.isLetter(grid[Y1+dY*i][X1+dX*i]))







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 7


  337	                        return false;
  338	                break;
  339	            case('q'):
  340	                dX = X2-X1;
  341	                dY = Y2-Y1;
  342	                //dX or dY must be 0 or abs dX must equal abs dY
  343	                if(Math.abs(dX) != Math.abs(dY) && dX != 0 && dY != 0)
  344	                    return false;
  345	
  346	                dist = (dX==0?Math.abs(dY):Math.abs(dX));
  347	                dX = (dX==0?0:dX/Math.abs(dX));
  348	                dY = (dY==0?0:dY/Math.abs(dY));
  349	                for(int i=1;i<dist;i++)
  350	                    if(Character.isLetter(grid[Y1+dY*i][X1+dX*i]))
  351	                        return false;
  352	                break;
  353	            case('k'):
  354	                dX = X2-X1;
  355	                dY = Y2-Y1;
  356	                if(Math.abs(dY) > 1)
  357	                    return false;
  358	                if(Math.abs(dX) > 1) {
  359	                    if(Math.abs(dX) > 2 || Y1 != Y2)
  360	                        return false;
  361	                    boolean left = (team==1?castleL1:castleL2);
  362	                    boolean right = (team==1?castleR1:castleR2);
  363	                    if(dX > 0) {
  364	                        if(!right)
  365	                            return false;
  366	                        if(Character.isLetter(grid[Y1][X1+1]) || Character.isLetter(grid[Y2][X2]))
  367	                            return false;
  368	                        if(isInCheck(team))
  369	                            return false;
  370	                        grid[Y1][X1+1] = grid[Y1][X1];
  371	                        grid[Y1][X1] = '0';
  372	                        if(isInCheck(team)) {
  373	                            grid[Y1][X1] = grid[Y1][X1+1];
  374	                            grid[Y1][X1+1] = '0';
  375	                            return false;
  376	                        }
  377	                        grid[Y1][X2] = grid[Y1][X1+1];
  378	                        grid[Y1][X1+1] = '0';
  379	                        if(isInCheck(team)) {
  380	                            grid[Y1][X1] = grid[Y1][X2];
  381	                            grid[Y1][X2] = '0';
  382	                            return false;
  383	                        }
  384	                        grid[Y1][X1] = grid[Y1][X2];
  385	                        grid[Y1][X2] = '0';
  386	                    } else {
  387	                        if(!left)
  388	                            return false;
  389	                        if(Character.isLetter(grid[Y1][X1-1]) || Character.isLetter(grid[Y2][X2]) || Character.isLetter(grid[Y2][X1-3]))
  390	                            return false;
  391	                        if(isInCheck(team))
  392	                            return false;







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 8


  393	                        grid[Y1][X1-1] = grid[Y1][X1];
  394	                        grid[Y1][X1] = '0';
  395	                        if(isInCheck(team)) {
  396	                            grid[Y1][X1] = grid[Y1][X1-1];
  397	                            grid[Y1][X1-1] = '0';
  398	                            return false;
  399	                        }
  400	                        grid[Y1][X2] = grid[Y1][X1-1];
  401	                        grid[Y1][X1-1] = '0';
  402	                        if(isInCheck(team)) {
  403	                            grid[Y1][X1] = grid[Y1][X2];
  404	                            grid[Y1][X2] = '0';
  405	                            return false;
  406	                        }
  407	                        grid[Y1][X1-3] = grid[Y1][X2];
  408	                        grid[Y1][X2] = '0';
  409	                        if(isInCheck(team)) {
  410	                            grid[Y1][X1] = grid[Y1][X1-3];
  411	                            grid[Y1][X1-3] = '0';
  412	                            return false;
  413	                        }
  414	                        grid[Y1][X1] = grid[Y1][X1-3];
  415	                        grid[Y1][X1-3] = '0';
  416	                    }
  417	                }
  418	                break;
  419	        }
  420	
  421	        //if the piece is a king, don't worry about being in check, you've already won!
  422	        if(Character.toLowerCase(victim) == 'k')
  423	            return true;
  424	        boolean check = false;
  425	        grid[Y2][X2] = grid[Y1][X1];
  426	        grid[Y1][X1] = '0';
  427	        System.out.println("is this a valid move for team "+team);
  428	        check = isInCheck(team);
  429	        grid[Y1][X1] = grid[Y2][X2];
  430	        grid[Y2][X2] = victim;
  431	
  432	        return !check;
  433	    }
  434	
  435	    //consider castling and en passant to be legal moves
  436	
  437	    /**
  438	     * whether the player on team team has any legal moves to make
  439	     * @param team the team to check
  440	     * @return if team has legal moves
  441	     */
  442	    public boolean hasLegalMoves(int team) {
  443	        //go through each piece,
  444	        for(int i=0;i<8;i++) {
  445	            for(int j=0;j<8;j++) {
  446	                char piece = grid[i][j];
  447	                //if piece is not a piece or is on opposite team
  448	                if(!Character.isLetter(piece) || Character.isUpperCase(piece) != (team == 1))







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 9


  449	                    continue;
  450	                piece = Character.toLowerCase(piece);
  451	                int dir = (team==1?-1:1);
  452	                switch(piece) {
  453	                    //check for en passant here. actually since en passant happens through the normal pawn move, it'll get checked
  454	                    case('p'):
  455	                        if(validMove(j,i,j,i+dir) || validMove(j,i,j-1,i+dir) || validMove(j,i,j+1,i+dir) || validMove(j,i,j,i+2*dir))
  456	                            return true;
  457	                    case('r'):
  458	                        for(int k=0;k<8;k++)
  459	                            if(validMove(j,i,j,k) || validMove(j,i,k,i))
  460	                                return true;
  461	                        break;
  462	                    case('n'):
  463	                        for(int k=-2;k<=2;k+=4)
  464	                            for(int l=-1;l<=1;l+=2)
  465	                                if(validMove(j,i,j+l,i+k) || validMove(j,i,j+k,i+l))
  466	                                    return true;
  467	                        break;
  468	                    case('b'):
  469	                        for(int k=0;k<8;k++) {
  470	                            if(i+(j-k) < 8 && i+(j-k) >= 0 && validMove(j,i,k,i+(j-k)))
  471	                                return true;
  472	                            if(i-(j-k) < 8 && i-(j-k) >= 0 && validMove(j,i,k,i-(j-k)))
  473	                                return true;
  474	                        }
  475	                        break;
  476	                    case('q'):
  477	                        for(int k=0;k<8;k++)
  478	                            if(validMove(j,i,j,k) || validMove(j,i,k,i))
  479	                                return true;
  480	                        for(int k=0;k<8;k++) {
  481	                            if(i+(j-k) < 8 && i+(j-k) >= 0 && validMove(j,i,k,i+(j-k)))
  482	                                return true;
  483	                            if(i-(j-k) < 8 && i-(j-k) >= 0 && validMove(j,i,k,i-(j-k)))
  484	                                return true;
  485	                        }
  486	                        break;
  487	                    case('k'):
  488	                        for(int k=-1;k<=1;k++)
  489	                            for(int l=-1;l<=1;l++)
  490	                                if(validMove(j,i,j+k,i+l))
  491	                                    return true;
  492	                        //try to castle here
  493	                        if(validMove(j,i,j+2,i) || validMove(j,i,j-2,i))
  494	                            return true;
  495	                        break;
  496	                }
  497	            }
  498	        }
  499	
  500	        System.out.println("player "+team+" has no legal moves!");
  501	        return false;
  502	    }
  503	
  504	    /**







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 10


  505	     * if player is checkmated
  506	     * @param team player to check
  507	     * @return if player is checkmated
  508	     */
  509	    public boolean isCheckmated(int team) {
  510	        System.out.println("checking for checkmate..");
  511	        if(isInCheck(team) && !hasLegalMoves(team))
  512	            return true;
  513	
  514	        return false;
  515	    }
  516	
  517	    /**
  518	     * checks to see if team has legal moves, and if not, the game is a stalemate
  519	     * @param team team whose turn it is
  520	     * @return if the game ends in stalemate
  521	     */
  522	    public boolean isStalemate(int team) {
  523	        System.out.println("checking for stalemate..");
  524	        if(!hasLegalMoves(team) && !isInCheck(team))
  525	            return true;
  526	
  527	        return false;
  528	    }
  529	
  530	    /**
  531	     * if the player is in check
  532	     * @param team player to test
  533	     * @return if the player is in check
  534	     */
  535	    public boolean isInCheck(int team) {
  536	        System.out.println("is "+team+" in check?");
  537	        int kX = -1;
  538	        int kY = -1;
  539	        char kingChar = (team==1?'K':'k');
  540	        for(int i=0;i<8;i++) {
  541	            for(int j=0;j<8;j++) {
  542	                if(grid[i][j] == kingChar) {
  543	                    kX = j;
  544	                    kY = i;
  545	                    break;
  546	                }
  547	            }
  548	        }
  549	        //cycle through opponent of team's pieces
  550	        //try to move that piece to team's king
  551	        //if it's a valid move, return true for isInCheck
  552	        //else return false
  553	
  554	        for(int i=0;i<8;i++) {
  555	            for(int j=0;j<8;j++) {
  556	                if(Character.isUpperCase(grid[i][j]) != (team==1)) {
  557	                    if(validMove(j,i,kX,kY)) {
  558	                        System.out.println("player "+team+" is in check... the "+grid[i][j]+" at "+j+","+i+" can legally move to your king at "+kX+","+kY);
  559	                        return true;
  560	                    }







2012-03-17 22:21 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessGame.java Page 11


  561	                }
  562	            }
  563	        }
  564	
  565	        return false;
  566	    }
  567	}
























































2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import javax.swing.*;
    4	import java.awt.*;
    5	import java.awt.event.ActionEvent;
    6	import java.awt.event.ActionListener;
    7	import java.awt.event.MouseEvent;
    8	import java.awt.event.MouseListener;
    9	import java.util.ArrayList;
   10	
   11	/**
   12	 * Chess panel to be displayed in client, gets data from server and renders it, also provides interactivity between player and server
   13	 * things such as highlighting valid moves on the board, displaying whose turn it is, whether a player is in check, if a player has won,
   14	 * etc. Will soon have animations to illustrate moves. Currently highlights last moved piece
   15	 *
   16	 * @author Joseph Colicchio
   17	 * @version for CS56, Choice Points, Winter 2012
   18	 */
   19	
   20	public class ChessPanel extends GamePanel {
   21	    ChessGame game;
   22	    int player1, player2;
   23	//    ArrayList<Character> capt1, capt2;
   24	    JPanel menuButtons;
   25	
   26	    JButton playSpecButton;
   27	    LeaveButton leaveButton;
   28	    NewGameButton newGameButton;
   29	    FlippedBox flippedBox;
   30	    Image pieces;
   31	
   32	    public boolean isPlaying;
   33	    public int playerID;
   34	
   35	    int offsetX, offsetY;
   36	    int margin;
   37	    double gridSize;
   38	    int panelSize;
   39	    int topMargin = 40;
   40	    int bottomMargin = 30;
   41	
   42	    int cells = 8;
   43	    int selectX = -1;
   44	    int selectY = -1;
   45	
   46	    //the coordinates of the last move made by a player
   47	    int lastMoveX = -1;
   48	    int lastMoveY = -1;
   49	    //a timer for moving the piece across the gameboard
   50	    //when a new move happens, if the animation isn't done, finish it
   51	    //don't remove any victim pieces until it reaches its destination
   52	    //this doesn't work for en passant or castling
   53	    int animTimer;
   54	    int oldPosX = -1;
   55	    int oldPosY = -1;
   56	    boolean[][] validMoves;







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 2


   57	
   58	    boolean flipped;
   59	    //if a player is in check, check = that player's id
   60	    int check;
   61	    boolean promoting;
   62	
   63	    //TODO: service panel should ask for information about service, i.e. state, players, etc
   64	
   65	    public ChessPanel() {
   66	        pieces = Res.ChessPieces;
   67	        setLayout(new BorderLayout());
   68	        menuButtons = new JPanel();
   69	        add(BorderLayout.SOUTH, menuButtons);
   70	        playSpecButton = new PlaySpecButton();
   71	        playSpecButton.setAlignmentX(JButton.CENTER_ALIGNMENT);
   72	        leaveButton = new LeaveButton();
   73	        leaveButton.setAlignmentX(JButton.CENTER_ALIGNMENT);
   74	        newGameButton = new NewGameButton();
   75	        newGameButton.setAlignmentX(JButton.CENTER_ALIGNMENT);
   76	        newGameButton.setEnabled(false);
   77	        menuButtons.add(playSpecButton);
   78	        menuButtons.add(leaveButton);
   79	        menuButtons.add(newGameButton);
   80	
   81	        flippedBox = new FlippedBox();
   82	        menuButtons.add(flippedBox);
   83	        menuButtons.add(new JLabel("Flip Board?"));
   84	
   85	        game = new ChessGame();
   86	
   87	        ChessCanvas canvas = new ChessCanvas();
   88	        canvas.addMouseListener(canvas);
   89	        add(BorderLayout.CENTER, canvas);
   90	
   91	        flipped = false;
   92	        check = 0;
   93	//        capt1 = new ArrayList<Character>();
   94	//        capt2 = new ArrayList<Character>();
   95	        isPlaying = false;
   96	        player1 = player2 = -1;
   97	        validMoves = new boolean[8][8];
   98	        for(int i=0;i<8;i++)
   99	            for(int j=0;j<8;j++)
  100	                validMoves[i][j] = false;
  101	        JavaClient.javaClient.sendMessage("STATE;");
  102	    }
  103	
  104	    //TODO: background notification sounds
  105	
  106	    /**
  107	     * handles data from the server
  108	     * @param string data to process
  109	     */
  110	    @Override
  111	    public void handleMessage(String string) {
  112	        System.out.println("handling as Chess: "+string);







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 3


  113	        if(string.indexOf("INIT;") == 0) {
  114	            game.init();
  115	//            capt1 = new ArrayList<Character>();
  116	//            capt2 = new ArrayList<Character>();
  117	        } else if(string.indexOf("STATE[") == 0) {
  118	            game.setState(string);
  119	            check = (game.isInCheck(game.turn)?game.turn:0);
  120	            selectX = selectY = -1;
  121	        } else if(string.indexOf("MOVE[") == 0) {
  122	            String[] data = string.substring(5).split("]");
  123	            int pid = Integer.parseInt(data[0]);
  124	            String[] coords = data[1].split(",");
  125	            int X1 = Integer.parseInt(coords[0]);
  126	            int Y1 = Integer.parseInt(coords[1]);
  127	            int X2 = Integer.parseInt(coords[2]);
  128	            int Y2 = Integer.parseInt(coords[3]);
  129	
  130	//            if(Character.isLetter(game.grid[Y2][X2]))
  131	//                if(game.turn == 1)
  132	//                    capt1.add(game.grid[Y2][X2]);
  133	//                else
  134	//                    capt2.add(game.grid[Y2][X2]);
  135	
  136	//            game.grid[Y2][X2] = game.grid[Y1][X1];
  137	//            game.grid[Y1][X1] = '0';
  138	            game.tryMove(X1,Y1,X2,Y2);
  139	            game.turn = pid;
  140	            check = (game.isInCheck(game.turn)?game.turn:0);
  141	            selectX = selectY = -1;
  142	            lastMoveX = X2;
  143	            lastMoveY = Y2;
  144	        } else if(string.indexOf("PLAYERS;") == 0) {
  145	            String[] data = string.substring(8).split(",");
  146	            player1 = Integer.parseInt(data[0]);
  147	            player2 = Integer.parseInt(data[1]);
  148	            System.out.println(player1+", "+JavaClient.javaClient.clients.size());
  149	            if(player1 >= 0 && player1 < JavaClient.javaClient.clients.size()) {
  150	                game.player1 = JavaClient.javaClient.clients.get(player1);
  151	            } else
  152	                game.player1 = null;
  153	            if(player2 >= 0 && player2 < JavaClient.javaClient.clients.size())
  154	                game.player2 = JavaClient.javaClient.clients.get(player2);
  155	            else
  156	                game.player2 = null;
  157	
  158	            //if the user is currently playing
  159	            if(player1 == JavaClient.javaClient.id || player2 == JavaClient.javaClient.id) {
  160	                isPlaying = true;
  161	                if(player1 == JavaClient.javaClient.id)
  162	                    playerID = 1;
  163	                else {
  164	                    flippedBox.setSelected(true);
  165	                    flipped = true;
  166	                    playerID = 2;
  167	                }
  168	                //if the game has two players, and is ready to go







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 4


  169	                if(game.player1 != null && game.player2 != null) {
  170	                    newGameButton.setEnabled(true);
  171	//                    sizesBox.setEnabled(false);
  172	                } else {
  173	                    newGameButton.setEnabled(false);
  174	//                    sizesBox.setEnabled(true);
  175	                }
  176	            } else {
  177	                isPlaying = false;
  178	                playerID = 0;
  179	                newGameButton.setEnabled(false);
  180	//                if(game.player1 != null && game.player2 != null)
  181	//                    sizesBox.setEnabled(false);
  182	//                else
  183	//                    sizesBox.setEnabled(true);
  184	            }
  185	
  186	            if(isPlaying || game.player1 == null || game.player2 == null)
  187	                playSpecButton.setEnabled(true);
  188	            else
  189	                playSpecButton.setEnabled(false);
  190	        } else if(string.indexOf("WINNER;")==0) {
  191	            game.winner = Integer.parseInt(string.substring(7));
  192	            System.out.println("winner: "+game.winner);
  193	        } else if(string.indexOf("SIZE;") == 0) {
  194	            int size = Integer.parseInt(string.substring(5));
  195	            game.init();
  196	//            sizesBox.setSize(size);
  197	        } else if(string.indexOf("PROMOTE[") == 0) {
  198	            String[] data = string.substring(8).split("]");
  199	            int pid = Integer.parseInt(data[0]);
  200	            String[] coords = data[1].split(",");
  201	            int X1 = Integer.parseInt(coords[0]);
  202	            int Y1 = Integer.parseInt(coords[1]);
  203	            int X2 = Integer.parseInt(coords[2]);
  204	            int Y2 = Integer.parseInt(coords[3]);
  205	            
  206	            game.grid[Y2][X2] = game.grid[Y1][X1];
  207	            game.grid[Y1][X1] = '0';
  208	
  209	            lastMoveX = X2;
  210	            lastMoveY = Y2;
  211	            
  212	            if(playerID == pid)
  213	                promoting = true;
  214	        } else if(string.indexOf("PROMOTE;") == 0) {
  215	            String[] data = string.substring(8).split(",");
  216	            int X = Integer.parseInt(data[0]);
  217	            int Y = Integer.parseInt(data[1]);
  218	            char piece = data[2].charAt(0);
  219	            game.grid[Y][X] = piece;
  220	            check = (game.isInCheck(game.turn)?game.turn:0);
  221	            game.turn = 3-game.turn;
  222	        }
  223	    }
  224	







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 5


  225	    /**
  226	     * a chess canvas to paint the game state and interact with the user
  227	     */
  228	    class ChessCanvas extends JPanel implements MouseListener {
  229	
  230	        //TODO: animations for movement
  231	        //TODO: along with animations, highlight last move
  232	            //this'll also depend on info coming in, like en passant is weird, and castling, and pawn promotion, and how does a piece "die"?
  233	        //TODO: pawn promotion should look nicer, right now it serves its purpose but doesn't look nice
  234	        //TODO: attack color
  235	        //TODO: general problem: don't repaint every frame, only when changes happen?
  236	        //TODO: general problem: if two players, change settings to allow edits until the first move is played
  237	            //this probably means a new standard for when the game starts
  238	        @Override
  239	        public void paintComponent(Graphics g) {
  240	            super.paintComponent(g);
  241	
  242	            int totalWidth = getWidth();
  243	            int totalHeight = getHeight();
  244	
  245	            double gridHeight = totalHeight - topMargin - bottomMargin;
  246	            double gridWidth = totalWidth;
  247	            if(3*gridHeight < 2*gridWidth) {
  248	                panelSize = (int)gridHeight;
  249	                offsetX = (int)(totalWidth-panelSize*1.5)/2+panelSize*1/4;
  250	                offsetY = topMargin;
  251	            } else {
  252	                panelSize = (int)gridWidth*2/3;
  253	                offsetX = panelSize*1/4;
  254	                offsetY = (int)((gridHeight-panelSize)/2+topMargin);
  255	            }
  256	
  257	            gridSize = (double)(panelSize)/cells;
  258	            margin = (int)(panelSize/(33*cells))+1;
  259	
  260	            g.setColor(Color.white);
  261	            g.fillRect(0,0,getWidth(),getHeight());
  262	            if(!JavaClient.javaClient.connected || JavaClient.javaClient.clients == null)
  263	                return;
  264	
  265	            g.setColor(new Color(0x333333));
  266	
  267	            synchronized (game) {
  268	                for(int i=0;i<8;i++) {
  269	                    for(int j=0;j<8;j++) {
  270	                        int cellX = (flipped?7-j:j);
  271	                        int cellY = (flipped?7-i:i);
  272	                        g.setColor(new Color((cellX+cellY)%2==0?0xaaaaaa:0x777777));
  273	                        if(lastMoveX == j && lastMoveY == i)
  274	                            g.setColor(new Color((cellX+cellY)%2==0?0xcccccc:0x555555));
  275	                        if(selectX != -1 && selectY != -1) {
  276	                            if(selectX == j && selectY == i)
  277	                                g.setColor(new Color(0x88ccff));
  278	                            else if(validMoves[j][i])
  279	                                if(Character.isLetter(game.grid[i][j]) || (Character.toLowerCase(game.grid[selectY][selectX]) == 'p' && selectX != j))
  280	                                    g.setColor(new Color(0xeeaa66));







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 6


  281	                                else
  282	                                    g.setColor(new Color(0x66aaee));
  283	                        }
  284	                        g.fillRect((int)(offsetX+gridSize*cellX), (int)(offsetY+gridSize*cellY), (int)(gridSize*(cellX+1))-(int)(gridSize*cellX), (int)(gridSize*(cellY+1))-(int)(gridSize*cellY));
  285	                        //render the piece on top
  286	                        char piece = game.grid[i][j];
  287	                        int team;
  288	                        if(!Character.isLetter(piece))
  289	                            continue;
  290	                        team = (Character.isUpperCase(piece)?1:2);
  291	                        int type = -1;
  292	                        switch(Character.toLowerCase(piece)) {
  293	                            case('q'):
  294	                                type = 0;
  295	                                break;
  296	                            case('k'):
  297	                                type = 1;
  298	                                break;
  299	                            case('r'):
  300	                                type = 2;
  301	                                break;
  302	                            case('p'):
  303	                                type = 3;
  304	                                break;
  305	                            case('b'):
  306	                                type = 4;
  307	                                break;
  308	                            case('n'):
  309	                                type = 5;
  310	                                break;
  311	                        }
  312	
  313	                        g.drawImage(pieces,
  314	                                (int)(offsetX + cellX * gridSize), (int)(offsetY + cellY * gridSize),
  315	                                (int)(offsetX+(cellX+1)*gridSize), (int)(offsetY+(cellY+1)*gridSize),
  316	                                21*type+1, 21*(team-1)+1, 21*(type+1)-1, 21*team-1, null);
  317	                    }
  318	                }
  319	
  320	                if(player1 > -1)
  321	                    game.player1 = JavaClient.javaClient.clients.get(player1);
  322	                if(player2 > -1)
  323	                    game.player2 = JavaClient.javaClient.clients.get(player2);
  324	
  325	                String readyState = "";
  326	                if(game.player1 != null) {
  327	                    g.setColor(Color.red);
  328	                    g.drawString("Player 1: "+game.player1.name,offsetX,offsetY-23);
  329	                    g.drawImage(pieces,offsetX-25,offsetY-40,offsetX-5,offsetY-20,21,0,42,21,null);
  330	                } else
  331	                    readyState = "waiting for players";
  332	                if(game.player2 != null) {
  333	                    g.setColor(Color.blue);
  334	                    g.drawString("Player 2: " + game.player2.name, offsetX, offsetY-3);
  335	                    g.drawImage(pieces, offsetX - 25, offsetY - 20, offsetX - 5, offsetY, 21, 21, 42, 42, null);
  336	                } else







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 7


  337	                    readyState = "waiting for players";
  338	                
  339	//                System.out.println("well.."+game.player1+":"+player1+","+game.player2+":"+player2);
  340	
  341	            if(readyState.equals("")) {
  342	                if(game.winner == -1)
  343	                        readyState = "Stalemate!";
  344	                    else if(game.winner == 1)
  345	                        readyState = "Checkmate! "+game.player1.name+" wins!";
  346	                    else if(game.winner == 2)
  347	                        readyState = "Checkmate! "+game.player2.name+" wins!";
  348	                    else if(game.turn == 1)
  349	                        readyState = game.player1.name+"'s turn";
  350	                    else
  351	                        readyState = game.player2.name+"'s turn";
  352	                    if(game.turn == check)
  353	                       readyState += ", check!";
  354	                }
  355	
  356	                g.setColor(new Color(0x222222));
  357	                g.drawString(readyState,offsetX+panelSize/2-45,offsetY+panelSize+20);
  358	
  359	                int count1 = 0;
  360	                int count2 = 0;
  361	                for(int i=0;i<game.captured.size();i++) {
  362	                    char piece = game.captured.get(i);
  363	                    int team = (Character.isUpperCase(piece)?1:2);
  364	                    int capX = 0;
  365	                    switch(Character.toLowerCase(piece)) {
  366	                        case('q'):
  367	                            capX = 0;
  368	                            break;
  369	                        case('k'):
  370	                            capX = 1;
  371	                            break;
  372	                        case('r'):
  373	                            capX = 2;
  374	                            break;
  375	                        case('p'):
  376	                            capX = 3;
  377	                            break;
  378	                        case('b'):
  379	                            capX = 4;
  380	                            break;
  381	                        case('n'):
  382	                            capX = 5;
  383	                            break;
  384	                    }
  385	                    //display pieces in black
  386	                    int count;
  387	                    if(team == 1)
  388	                        count = count1++;
  389	                    else
  390	                        count = count2++;
  391	                    int posX = count/8;
  392	                    int posY = count%8;







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 8


  393	                    double teamX = ((team==2 == !flipped)?offsetX-(posX+1)*gridSize:offsetX+panelSize+posX*gridSize);
  394	                    g.drawImage(pieces,(int)(teamX),(int)(offsetY+posY*gridSize),(int)(teamX+gridSize),(int)(offsetY+(posY+1)*gridSize),
  395	                            capX*21,(team-1)*21,(capX+1)*21,(team)*21,null);
  396	                }
  397	                
  398	                if(promoting) {
  399	                    g.setColor(Color.white);
  400	                    g.fillRect((int)(offsetX+gridSize),(int)(offsetY+gridSize/2),(int)(gridSize*6),(int)(gridSize*2));
  401	                    g.setColor(new Color(0x3388ff));
  402	                    g.drawString("Promote:",(int)(offsetX+gridSize*3),(int)(offsetY+gridSize));
  403	                    g.setColor(new Color(0x1166dd));
  404	                    g.drawRect((int)(offsetX+gridSize*1.25),(int)(offsetY+gridSize*1.25),
  405	                            (int)(gridSize),(int)(gridSize));
  406	                    g.drawRect((int)(offsetX+gridSize*2.75),(int)(offsetY+gridSize*1.25),
  407	                            (int)(gridSize),(int)(gridSize));
  408	                    g.drawRect((int)(offsetX+gridSize*4.25),(int)(offsetY+gridSize*1.25),
  409	                            (int)(gridSize),(int)(gridSize));
  410	                    g.drawRect((int)(offsetX+gridSize*5.75),(int)(offsetY+gridSize*1.25),
  411	                            (int)(gridSize),(int)(gridSize));
  412	                    int type = (playerID == 0 ? 0:1);
  413	                    g.drawImage(pieces,(int)(offsetX+gridSize*1.25),(int)(offsetY+gridSize*1.25),(int)(offsetX+gridSize*(1.25+1)),(int)(offsetY+gridSize*(1.25+1)),
  414	                            0,21*type,21,21*(type+1),null);
  415	                    g.drawImage(pieces,(int)(offsetX+gridSize*2.75),(int)(offsetY+gridSize*1.25),(int)(offsetX+gridSize*(2.75+1)),(int)(offsetY+gridSize*(1.25+1)),
  416	                            21*2,21*type,21*3,21*(type+1),null);
  417	                    g.drawImage(pieces,(int)(offsetX+gridSize*4.25),(int)(offsetY+gridSize*1.25),(int)(offsetX+gridSize*(4.25+1)),(int)(offsetY+gridSize*(1.25+1)),
  418	                            21*4,21*type,21*5,21*(type+1),null);
  419	                    g.drawImage(pieces,(int)(offsetX+gridSize*5.75),(int)(offsetY+gridSize*1.25),(int)(offsetX+gridSize*(5.75+1)),(int)(offsetY+gridSize*(1.25+1)),
  420	                            21*5,21*type,21*6,21*(type+1),null);
  421	                }
  422	            }
  423	        }
  424	        @Override
  425	        public void mouseClicked(MouseEvent mouseEvent){ }
  426	
  427	        @Override
  428	        public void mousePressed(MouseEvent mouseEvent){
  429	            if(!isPlaying || game.player2 == null)
  430	                return;
  431	
  432	            //To change body of implemented methods use File | Settings | File Templates.
  433	            int mX = mouseEvent.getX();
  434	            int mY = mouseEvent.getY();
  435	            int dX = mX-offsetX;
  436	            int dY = mY-offsetY;
  437	
  438	            if(promoting) {
  439	                if(dY < gridSize*1.25 || dY > gridSize*2.25 || dX < gridSize*1.25 || dX > gridSize*(6.75))
  440	                    return;
  441	                
  442	                char piece;
  443	                if(dX > gridSize*1.25 && dX < gridSize*2.25)
  444	                    piece = 'q';
  445	                else if(dX > gridSize*2.75 && dX < gridSize*3.75)
  446	                    piece = 'r';
  447	                else if(dX > gridSize*4.25 && dX < gridSize*5.25)
  448	                    piece = 'b';







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 9


  449	                else if(dX > gridSize*5.75 && dX < gridSize*6.75)
  450	                    piece = 'n';
  451	                else
  452	                    return;
  453	                
  454	                if(playerID == 1)
  455	                    piece = Character.toUpperCase(piece);
  456	                
  457	                JavaClient.javaClient.sendMessage("PROMOTE;"+lastMoveX+","+lastMoveY+","+piece);
  458	                promoting = false;
  459	            }
  460	            int cellX = (dX*cells/panelSize);
  461	            int cellY = (dY*cells/panelSize);
  462	            
  463	//            System.out.println(mX+", "+mY+", "+dX+", "+dY+", "+cellX+", "+cellY);
  464	
  465	            if(cellX < 0 || cellX >= cells || cellY < 0 || cellY >= cells)
  466	                return;
  467	            
  468	            if(flipped) {
  469	                cellX = 7-cellX;
  470	                cellY = 7-cellY;
  471	            }
  472	
  473	            //run the code a second time
  474	            for(int i=0;i<2;i++) {
  475	                if(i == 0 && (selectX == -1 || selectY == -1))
  476	                    continue;
  477	                if(selectX == -1 || selectY == -1) {
  478	                    if(game.turn != playerID)
  479	                        break;
  480	                     if(!Character.isLetter(game.grid[cellY][cellX]))
  481	                        break;
  482	                    if(Character.isUpperCase(game.grid[cellY][cellX]) != (playerID == 1))
  483	                        break;
  484	
  485	                    selectX = cellX;
  486	                    selectY = cellY;
  487	                } else {
  488	                    JavaClient.javaClient.sendMessage("MOVE;" + selectX+","+selectY+","+cellX + "," + cellY);
  489	                    boolean breakOut = (selectX == cellX && selectY == cellY);
  490	                    selectX = -1;
  491	                    selectY = -1;
  492	                    if(breakOut)
  493	                        break;
  494	                }
  495	            }
  496	            
  497	            //calculate all valid moves
  498	            if(selectX == -1 || selectY == -1)
  499	                return;
  500	            for(int i=0;i<8;i++)
  501	                for(int j=0;j<8;j++)
  502	                    validMoves[j][i] = game.validMove(selectX,selectY,j,i);
  503	        }
  504	        @Override







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 10


  505	        public void mouseReleased(MouseEvent mouseEvent){ }
  506	        @Override
  507	        public void mouseEntered(MouseEvent mouseEvent){ }
  508	        @Override
  509	        public void mouseExited(MouseEvent mouseEvent){ }
  510	    }
  511	
  512	    /** a button to allow users to play or spectate
  513	     *
  514	     */
  515	    class PlaySpecButton extends JButton implements ActionListener{
  516	        public boolean playing;
  517	        public PlaySpecButton() {
  518	            super("Play");
  519	            playing = false;
  520	            addActionListener(this);
  521	        }
  522	
  523	        @Override
  524	        public void actionPerformed(ActionEvent actionEvent){
  525	            if(playing) {
  526	                JavaClient.javaClient.sendMessage("MSG;/spec");
  527	                setText("Play");
  528	                playing = false;
  529	            } else {
  530	                JavaClient.javaClient.sendMessage("MSG;/play");
  531	                setText("Spectate");
  532	                playing = true;
  533	            }
  534	        }
  535	    }
  536	
  537	    /**
  538	     * a button to allow players to leave the service and join the lobby
  539	     */
  540	    class LeaveButton extends JButton implements ActionListener{
  541	        public LeaveButton() {
  542	            super("Leave");
  543	            addActionListener(this);
  544	        }
  545	
  546	        @Override
  547	        public void actionPerformed(ActionEvent actionEvent){
  548	            JavaClient.javaClient.sendMessage("MSG;/join lobby");
  549	        }
  550	    }
  551	
  552	    /**
  553	     * a button to allow players who are playing to start a new game
  554	     */
  555	    class NewGameButton extends JButton implements ActionListener {
  556	        public NewGameButton() {
  557	            super("New Game");
  558	            addActionListener(this);
  559	        }
  560	







2012-03-17 22:26 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessPanel.java Page 11


  561	        @Override
  562	        public void actionPerformed(ActionEvent actionEvent) {
  563	            JavaClient.javaClient.sendMessage("MSG;/newgame");
  564	        }
  565	    }
  566	
  567	    /**
  568	     * a checkbox to flip the board 180 degrees
  569	     */
  570	    class FlippedBox extends JCheckBox implements ActionListener {
  571	        public FlippedBox() {
  572	            super();
  573	            addActionListener(this);
  574	        }
  575	        
  576	        public void actionPerformed(ActionEvent event) {
  577	            flipped = isSelected();
  578	        }
  579	    }
  580	}











































2012-03-17 16:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessService.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * Chess service is run by the server and essentially connects the clients to the server's copy of the chess game
    5	 * Can exist multiple chessservices on the server for different players, however the GUI does not as of yet provide
    6	 * the ability for players to create new games. Players can type /new Chess to make a new game and join it, however
    7	 *
    8	 * @author Joseph Colicchio
    9	 * @version for CS56, Choice Points, Winter 2012
   10	 */
   11	
   12	public class ChessService extends TwoPlayerGameService {
   13	    public ChessGame gameData;
   14	
   15	    public ClientConnect player1;
   16	    public ClientConnect player2;
   17	
   18	    public boolean gameStarted;
   19	
   20	    /**
   21	     * start the service with id number ID
   22	     * @param ID id of the service
   23	     */
   24	    public ChessService(int ID) {
   25	        super(ID);
   26	        gameData = new ChessGame();
   27	        type = 3;
   28	        name = "Chess";
   29	    }
   30	    //TODO: service addClient shouldn't send the client any info
   31	
   32	    /** initialize the service
   33	     *
   34	     */
   35	    public void init() {
   36	        gameData.init();
   37	        broadcastData("INIT;");
   38	    }
   39	
   40	    /**
   41	     * set client as a player of the game, if possible
   42	     * @param client client to make a player
   43	     */
   44	    public void playClient(ClientConnect client) {
   45	        if(player1 == null) {
   46	            player1 = client;
   47	            gameData.player1 = client.client;
   48	        } else if(player2 == null && player1 != client) {
   49	            player2 = client;
   50	            gameData.player2 = client.client;
   51	            gameStarted = true;
   52	            System.out.println("ready to play: "+player1.client.id+" vs "+player2.client.id);
   53	            gameData.init();
   54	        }
   55	
   56	        updateAll();







2012-03-17 16:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessService.java Page 2


   57	    }
   58	
   59	    //if a client was a player, spec him, and then probably stop the game
   60	
   61	    /**
   62	     * set playing client as spectator instead
   63	     * @param client client to stop from playing
   64	     */
   65	    public void specClient(ClientConnect client) {
   66	        if(player1 != client && player2 != client)
   67	            return;
   68	        if(player1 == client) {
   69	            player1 = player2;
   70	            gameData.player1 = gameData.player2;
   71	            player2 = null;
   72	            gameData.player2 = null;
   73	            gameStarted = false;
   74	            gameData.init();
   75	        }
   76	        if(player2 == client) {
   77	            player2 = null;
   78	            gameData.player2 = null;
   79	            gameStarted = false;
   80	            gameData.init();
   81	        }
   82	
   83	        updateAll();
   84	    }
   85	
   86	    //get move from player, if it's their turn
   87	
   88	    /**
   89	     * handle data from server
   90	     * @param client the client sending the data
   91	     * @param string data to handle
   92	     */
   93	    public void handleData(ClientConnect client, String string) {
   94	        if(string.indexOf("PLAY;") == 0)
   95	            playClient(client);
   96	        else if(string.indexOf("SPEC;") == 0)
   97	            specClient(client);
   98	        else if(string.indexOf("MSG;") == 0) {
   99	            String message = string.substring(4);
  100	            if(message.indexOf("/play")==0) {
  101	                playClient(client);
  102	            } else if(message.indexOf("/spec") == 0) {
  103	                specClient(client);
  104	            } else if(message.indexOf("/newgame") == 0) {
  105	                if(client == player1 || client == player2)
  106	                    init();
  107	            } else
  108	                super.handleData(client, string);
  109	        }
  110	        //TODO: new standard for sending information about the service to the client
  111	
  112	        if(!gameStarted || gameData.winner > 0)







2012-03-17 16:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessService.java Page 3


  113	            return;
  114	        System.out.println(gameData.turn+", "+client.client.id+", "+player1.client.id+":"+player2.client.id);
  115	        if(gameData.turn == 1 && client != player1)
  116	            return;
  117	        if(gameData.turn == 2 && client != player2)
  118	            return;
  119	        if(string.indexOf("MOVE;") == 0) {
  120	            System.out.println("got move command from "+client.client.id+": "+string);
  121	            String[] data = string.substring(5).split(",");
  122	            int X1 = Integer.parseInt(data[0]);
  123	            int Y1 = Integer.parseInt(data[1]);
  124	            int X2 = Integer.parseInt(data[2]);
  125	            int Y2 = Integer.parseInt(data[3]);
  126	
  127	            if(gameData.tryMove(X1,Y1,X2,Y2)) {
  128	                System.out.println("move went through");
  129	                char piece = gameData.grid[Y2][X2];
  130	                //intercept castling and en passant here, don't send move[]
  131	                if(Character.toLowerCase(piece) == 'p' && Y2 == (Character.isUpperCase(piece)?0:7)) {
  132	                    broadcastData("PROMOTE["+gameData.turn+"]"+X1+","+Y1+","+X2+","+Y2);
  133	                } else {
  134	                    gameData.turn = 3-gameData.turn;
  135	                    broadcastData("MOVE[" + gameData.turn + "]"+X1+","+Y1+","+X2+","+Y2);
  136	                    if(gameData.checkWinner())
  137	                        broadcastData("WINNER;"+gameData.winner);
  138	                }
  139	            }
  140	        } else if(string.indexOf("PROMOTE;") == 0) {
  141	            String[] data = string.substring(8).split(",");
  142	            int X = Integer.parseInt(data[0]);
  143	            int Y = Integer.parseInt(data[1]);
  144	            char piece = data[2].charAt(0);
  145	            gameData.grid[Y][X] = piece;
  146	            gameData.turn = 3-gameData.turn;
  147	            broadcastData("PROMOTE;"+X+","+Y+","+piece);
  148	            if(gameData.checkWinner())
  149	                broadcastData("WINNER;"+gameData.winner);
  150	        }
  151	    }
  152	
  153	    //sends the state of the game to a player
  154	
  155	    /**
  156	     * send the client the state of the game
  157	     * @param client client to send to
  158	     */
  159	    public void sendGameState(ClientConnect client) {
  160	        if(client == null)
  161	            return;
  162	        synchronized (clients) {
  163	            client.sendMessage(gameData.getState());
  164	            String players = "PLAYERS;";
  165	            if(gameData.player1 != null)
  166	                players += gameData.player1.id;
  167	            else
  168	                players += "-1";







2012-03-17 16:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ChessService.java Page 4


  169	            players += ",";
  170	            if(gameData.player2 != null)
  171	                players += gameData.player2.id;
  172	            else
  173	                players += "-1";
  174	
  175	            client.sendMessage(players);
  176	        }
  177	    }
  178	}





















































2012-03-17 16:35 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ClientConnect.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import java.io.BufferedReader;
    4	import java.io.IOException;
    5	import java.io.InputStreamReader;
    6	import java.io.PrintWriter;
    7	import java.net.Socket;
    8	
    9	/**
   10	 * Clientconnect is a runnable object representing a connection between the server and a client
   11	 * it provides all functionality for transmitting data to clients and receiving incoming data from them
   12	 *
   13	 * @author Joseph Colicchio
   14	 * @version for CS56, Choice Points, Winter 2012
   15	 */
   16	
   17	//server-wide convention for managing cilents connected to server
   18	public class ClientConnect implements Runnable {
   19	    Socket sock;
   20	    BufferedReader reader;
   21	    PrintWriter writer;
   22	
   23	    boolean closed;
   24	
   25	    //the client data object
   26	    public ClientObject client;
   27	
   28	    public Service currentService;
   29	
   30	    //setup
   31	
   32	    /**
   33	     * set up the clientconnect with a socket
   34	     * @param clientSocket active connection to server
   35	     */
   36	    public ClientConnect(Socket clientSocket) {
   37	        if(clientSocket == null)
   38	            return;
   39	        if(JavaServer.isBanned(clientSocket.getRemoteSocketAddress().toString()))
   40	            closed = true;
   41	        else
   42	            closed = false;
   43	        System.out.println("new thing");
   44	        try {
   45	            sock = clientSocket;
   46	            reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));
   47	            writer = new PrintWriter(sock.getOutputStream());
   48	        } catch(Exception ex) {
   49	            ex.printStackTrace();
   50	        }
   51	    }
   52	
   53	    //life cycle of the client
   54	    public void run() {
   55	        System.out.println("running");
   56	        synchronized (JavaServer.clients) {







2012-03-17 16:35 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ClientConnect.java Page 2


   57	            for(int i=0;i<JavaServer.clients.size();i++) {
   58	                if(JavaServer.clients.get(i) == null) {
   59	                    client = new ClientObject(i);
   60	                    JavaServer.clients.set(i,this);
   61	                    break;
   62	                }
   63	            }
   64	            if(client == null) {
   65	                client = new ClientObject(JavaServer.clients.size());
   66	                JavaServer.clients.add(this);
   67	                JavaServer.updateServerGUI();
   68	            }
   69	        }
   70	
   71	        //tell client what its id is
   72	        sendMessage("ID;"+client.id);
   73	        currentService = JavaServer.lobby;
   74	        currentService.addClient(this);
   75	        //edu.ucsb.cs56.W12.jcolicchio.issue535.JavaServer.broadcastMessage("CON;"+client.id);
   76	
   77	        //tell everyone else, player id has joined
   78	
   79	        //edu.ucsb.cs56.W12.jcolicchio.issue535.JavaServer.ActiveGame.addClient(this);
   80	
   81	        String str;
   82	        try {
   83	            while(!closed && (str = reader.readLine()) != null) {
   84	                //do something with str
   85	                handleMessage(str);
   86	            }
   87	        } catch(Exception ex) {
   88	            System.out.println("closed? "+closed);
   89	            ex.printStackTrace();
   90	            JavaServer.broadcastMessage("DCON["+client.id+"]Client crashed!");
   91	        }
   92	
   93	        try{
   94	            System.out.println("closing this");
   95	            writer.close();
   96	            reader.close();
   97	            sock.close();
   98	        }catch(IOException e){
   99	            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
  100	        }
  101	
  102	        //tell everyone the client has disconnected
  103	        currentService.removeClient(this);
  104	        System.out.println(closed+" well at least this got called...");
  105	        synchronized (JavaServer.clients) {
  106	            JavaServer.clients.set(client.id, null);
  107	            if(client.id == JavaServer.clients.size()-1){
  108	                for(int i=client.id;i>=0;i--) {
  109	                    if(JavaServer.clients.get(i) == null) {
  110	                        JavaServer.clients.remove(i);
  111	                    } else {
  112	                        break;







2012-03-17 16:35 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ClientConnect.java Page 3


  113	                    }
  114	                }
  115	            }
  116	        }
  117	        JavaServer.updateServerGUI();
  118	    }
  119	
  120	    /**
  121	     * handle data from client
  122	     * @param string data from client
  123	     */
  124	    public void handleMessage(String string) {
  125	        //this should send the message to the current service as well
  126	
  127	        System.out.println("incoming... "+string);
  128	        //do something with the message from the client
  129	        if(string.indexOf("CON;") == 0) {
  130	            //if incoming is CON;, alert everyone that cilent.id has connected
  131	            JavaServer.broadcastMessage("CON;"+client.id);
  132	        } else if(string.indexOf("DCON;") == 0) {
  133	            //if incoming is DCON;, alert everyone that client.id has disconnected
  134	            disconnect(string.substring(5));
  135	        } else if(string.indexOf("INFO;") == 0) {
  136	            sendServers();
  137	            sendAll();
  138	        } else if(string.indexOf("NAME;") == 0) {
  139	            //change this to just call a function with two parameters
  140	            //it's susceptible to users who try to enter with names that contain ', ], etc
  141	            if(JavaServer.findClientByName(string.substring(5)) > -1)
  142	                rename(JavaServer.findUnusedName());
  143	            else
  144	                rename(string.substring(5));
  145	        }
  146	
  147	        currentService.handleData(this, string);
  148	    }
  149	
  150	    /**
  151	     * send all connected user info to client
  152	     */
  153	    public void sendAll() {
  154	        String r = "ALL;";
  155	        synchronized (JavaServer.clients) {
  156	        System.out.println("total users: "+JavaServer.clients.size());
  157	        ClientConnect client;
  158	            for(int i=0;i<JavaServer.clients.size();i++) {
  159	                client = JavaServer.clients.get(i);
  160	                if(client == null)
  161	                    r += ",";
  162	                else
  163	                    r += client.client.name+","+client.client.location;
  164	                if(i < JavaServer.clients.size()-1)
  165	                    r += ";";
  166	            }
  167	        }
  168	        sendMessage(r);







2012-03-17 16:35 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ClientConnect.java Page 4


  169	    }
  170	
  171	    /**
  172	     * send all info about services to client
  173	     */
  174	    public void sendServers() {
  175	        String r = "SERV;"+JavaServer.services.get(0).type;
  176	        synchronized (JavaServer.clients) {
  177	            for(int i=1;i<JavaServer.services.size();i++)
  178	                r += ","+JavaServer.services.get(i).type;
  179	        }
  180	        sendMessage(r);
  181	    }
  182	
  183	    /**
  184	     * try kick the user off the server with optional message
  185	     * @param message optional message to display to all users
  186	     */
  187	    public void kick(String message) {
  188	        String reason = null;
  189	        int id = -1;
  190	        String clientName;
  191	        String[] data;
  192	        if(message.indexOf(" ") == -1)
  193	            clientName = message;
  194	        else {
  195	            data = message.split(" ");
  196	            clientName = data[0];
  197	            reason = message.substring(data[0].length()+1);
  198	        }
  199	
  200	        id = JavaServer.findClientByName(clientName);
  201	        if(id < 0) {
  202	            fromServer("Could not find user: "+clientName);
  203	            return;
  204	        }
  205	
  206	        ClientConnect victim = JavaServer.clients.get(id);
  207	        if(reason == null || reason.equals(""))
  208	            victim.disconnect("Kicked by "+client.name);
  209	        else
  210	            victim.disconnect("Kicked by "+client.name+". Reason: "+reason);
  211	    }
  212	
  213	    /**
  214	     * ban a user's ip from connecting to the server
  215	     * @param message option ban message
  216	     */
  217	    public void ban(String message) {
  218	        String[] data = message.split(" ");
  219	
  220	        int id = JavaServer.findClientByName(data[0]);
  221	        if(id < 0) {
  222	            fromServer("Could not find user: "+data[0]);
  223	            return;
  224	        }







2012-03-17 16:35 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ClientConnect.java Page 5


  225	        ClientConnect victim = JavaServer.clients.get(id);
  226	        JavaServer.banIP(victim.sock.getRemoteSocketAddress().toString());
  227	    }
  228	
  229	    /**
  230	     * unban an ip
  231	     * @param message message to display while unbanning
  232	     */
  233	    public void unban(String message) {
  234	        String[] data = message.split(" ");
  235	
  236	        int id = JavaServer.findClientByName(data[0]);
  237	        if(id < 0) {
  238	            fromServer("Could not find user: "+data[0]);
  239	            return;
  240	        }
  241	        ClientConnect victim = JavaServer.clients.get(id);
  242	        JavaServer.unbanIP(victim.sock.getRemoteSocketAddress().toString());
  243	    }
  244	
  245	    /**
  246	     * kick and ban a user with message
  247	     * @param message message to display
  248	     */
  249	    public void kickBan(String message) {
  250	        kick(message);
  251	        ban(message);
  252	    }
  253	
  254	    //quit with optional message
  255	
  256	    /** disconnect this client with message
  257	     *
  258	     * @param message message to display
  259	     */
  260	    public void disconnect(String message) {
  261	        closed = true;
  262	        String msg = "DCON["+client.id+"]";
  263	        if(message != null)
  264	            msg += message;
  265	        JavaServer.broadcastMessage(msg);
  266	    }
  267	
  268	    //sends message to client
  269	
  270	    /**
  271	     * send message to client, could be any kind of data
  272	     * @param string data to send
  273	     */
  274	    public void sendMessage(String string) {
  275	        if(writer == null)
  276	            return;
  277	        System.out.println("outgoing to "+client.id+"... "+string);
  278	        writer.println(string);
  279	        writer.flush();
  280	    }







2012-03-17 16:35 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ClientConnect.java Page 6


  281	
  282	    /**
  283	     * attempt to rename client
  284	     * @param newName new name to give to client
  285	     */
  286	    public void rename(String newName) {
  287	        if(newName == null || newName.equals(""))
  288	            return;
  289	        if(newName.indexOf(",") != -1
  290	                || newName.indexOf("]") != -1
  291	                || newName.indexOf("/") != -1
  292	                || newName.indexOf(" ") != -1) {
  293	            fromServer("Invalid name: \""+newName+"\", cannot contain ' ', '/', ']' or ','");
  294	            return;
  295	        }
  296	        if(JavaServer.findClientByName(newName) >= 0) {
  297	            fromServer("Name \""+newName+"\" already taken!");
  298	            return;
  299	        }
  300	
  301	        //this doesn't belong here
  302	        if(!client.name.equals(""))
  303	            JavaServer.broadcastMessage("SMSG;"+client.name+" changed name to "+newName);
  304	        client.name = newName;
  305	        JavaServer.broadcastMessage("NAME["+client.id+"]"+client.name);
  306	    }
  307	
  308	    /** send a message as the server
  309	     *
  310	     * @param string message to send
  311	     */
  312	    public void fromServer(String string) {
  313	        sendMessage("SMSG;"+string);
  314	    }
  315	
  316	    /**
  317	     * promote user to operator status, if possible
  318	     * @param user username
  319	     */
  320	    public void op(String user) {
  321	        if(!client.isOp) {
  322	            fromServer("You can't make "+user+" OP because you are not OP!");
  323	            return;
  324	        }
  325	
  326	        int userID = JavaServer.findClientByName(user);
  327	        if(userID != -1)
  328	            JavaServer.broadcastMessage("OP;"+userID);
  329	    }
  330	}













2012-03-17 04:35 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ClientObject.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import java.util.ArrayList;
    4	
    5	/**
    6	 * Client object is a standard way to store info about a client, whether on the server or client side
    7	 * On the client site, client objects represent peer clients, since no actual variables for these clients are provided
    8	 * and the knowledge of their existence is provided only via strings from the server
    9	 *
   10	 * @author Joseph Colicchio
   11	 * @version for CS56, Choice Points, Winter 2012
   12	 */
   13	
   14	public class ClientObject{
   15	    int id;
   16	    String name;
   17	    int location;
   18	
   19	    boolean isOp;
   20	
   21	    static ArrayList<Integer> colors;
   22	    static boolean _init;
   23	
   24	    public ClientObject(int n) {
   25	        //new client object made, stores data about client
   26	        id = n;
   27	        name = "User"+n;
   28	        location = 0;
   29	    }
   30	    
   31	    public ClientObject(int n, String NAME, int LOCATION) {
   32	        id = n;
   33	        name = NAME;
   34	        location = LOCATION;
   35	    }
   36	
   37	    public static void init() {
   38	        colors = new ArrayList<Integer>();
   39	        colors.add(0xff0000);
   40	        colors.add(0xffff00);
   41	        colors.add(0x00ff00);
   42	        colors.add(0x00ffff);
   43	        colors.add(0x0000ff);
   44	        colors.add(0xff00ff);
   45	    }
   46	    
   47	    public int getColor() {
   48	        if(!_init) {
   49	            init();
   50	        }
   51	
   52	        return colors.get(id%colors.size());
   53	    }
   54	}









2012-03-17 15:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/EchoConnect.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * Echo connect was removed from the server, but used to be a dummy client which, when privately messaged by a real client,
    5	 * would respond via private message to that user with the same message
    6	 *
    7	 * @author Joseph Colicchio
    8	 * @version for CS56, Choice Points, Winter 2012
    9	 */
   10	
   11	public class EchoConnect extends ClientConnect {
   12	    public EchoConnect(int id) {
   13	        super(null);
   14	        client = new ClientObject(id,"Echo",0);
   15	    }
   16	
   17	    @Override
   18	    public void sendMessage(String string) {
   19	        //System.out.println("echo got msg: "+string);
   20	        if(string.indexOf("PMSG[") == 0) {
   21	            String[] data = string.substring(5).split("]");
   22	            int id = Integer.parseInt(data[0]);
   23	            if(id == client.id)
   24	                return;
   25	            String msg = string.substring(5+data[0].length()+1);
   26	            System.out.println("echo said this: "+msg);
   27	            handleMessage("MSG;/msg "+JavaServer.clients.get(id).client.name+" "+string.substring(5+data[0].length()+1));
   28	        }
   29	    }
   30	}

































2012-03-17 16:36 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GamePanel.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import javax.swing.*;
    4	import java.awt.*;
    5	import java.awt.event.MouseEvent;
    6	import java.awt.event.MouseListener;
    7	
    8	/**
    9	 * Game panel is a largely abstract panel that provides an outline for how panels should be formatted, as well as provides
   10	 * basic functions every panel should have. Might consider turning this into an interface, but before the offlinepanel existed,
   11	 * gamepanel was used when a client was disconnected
   12	 *
   13	 * @author Joseph Colicchio
   14	 * @version for CS56, Choice Points, Winter 2012
   15	 */
   16	
   17	public class GamePanel extends JPanel implements MouseListener{
   18	    public GamePanel() {
   19	        setLayout(new BorderLayout());
   20	    }
   21	
   22	    /**
   23	     * update the game
   24	     */
   25	    public void update() {
   26	
   27	    }
   28	
   29	    /**
   30	     * handle incoming data from server
   31	     * @param string data
   32	     */
   33	    public void handleMessage(String string) {
   34	
   35	    }
   36	
   37	    @Override
   38	    public void mouseClicked(MouseEvent mouseEvent){
   39	    }
   40	
   41	    @Override
   42	    public void mousePressed(MouseEvent mouseEvent){
   43	    }
   44	
   45	    @Override
   46	    public void mouseReleased(MouseEvent mouseEvent){
   47	    }
   48	
   49	    @Override
   50	    public void mouseEntered(MouseEvent mouseEvent){
   51	    }
   52	
   53	    @Override
   54	    public void mouseExited(MouseEvent mouseEvent){
   55	    }
   56	}







2012-03-17 16:37 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuGame.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	
    4	/**
    5	 * gomoku game is a game object that stores data about a game of gomoku, or 5-in-a-row
    6	 * like other game objects, it provides functionality for sending and receiving game states, as well as win detection
    7	 *
    8	 * @author Joseph Colicchio
    9	 * @version for CS56, Choice Points, Winter 2012
   10	 */
   11	
   12	public class GomokuGame{
   13	    public ClientObject player1, player2;
   14	
   15	    public int[][] grid;
   16	    public int turn;
   17	    public int winner;
   18	    
   19	    public int cells;
   20	
   21	    public GomokuGame() {
   22	        init(9);
   23	    }
   24	
   25	    /**
   26	     * initialize as size
   27	     * @param CELLS width and height of game board
   28	     */
   29	    public void init(int CELLS) {
   30	        cells = CELLS;
   31	        grid = new int[cells][cells];
   32	        for(int i=0;i<cells;i++)
   33	            for(int j=0;j<cells;j++)
   34	                grid[i][j] = 0;
   35	
   36	        turn = 1;
   37	        winner = 0;
   38	    }
   39	
   40	    /**
   41	     * check winner of game
   42	     * @return if the game has a winner
   43	     */
   44	    public boolean checkWinner() {
   45	        for(int i=0;i<cells;i++) {
   46	            for(int j=0;j<cells;j++) {
   47	                int type = grid[i][j];
   48	                if(type == 0)
   49	                    continue;
   50	
   51	                //vertical
   52	                if(i < cells-4 && recursiveCheckWin(type, j, i, 0, 4)) {
   53	                    winner = type;
   54	                    return true;
   55	                }
   56	                //horizontal







2012-03-17 16:37 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuGame.java Page 2


   57	                if(j < cells-4 && recursiveCheckWin(type, j, i, 2, 4)) {
   58	                    winner = type;
   59	                    return true;
   60	                }
   61	                //down-right
   62	                if(i < cells-4 && j < cells-4 && recursiveCheckWin(type, j, i, 1, 4)) {
   63	                    winner = type;
   64	                    return true;
   65	                }
   66	                //down-left
   67	                if(i < cells-4 && j > 3 && recursiveCheckWin(type, j, i, 3, 4)) {
   68	                    winner = type;
   69	                    return true;
   70	                }
   71	            }
   72	        }
   73	        System.out.println("no winner found");
   74	        return false;
   75	    }
   76	
   77	    private boolean recursiveCheckWin(int type, int X, int Y, int dir, int count) {
   78	        if(count < 0) {
   79	            if(X < cells && X >= 0 && Y < cells && Y >= 0 && grid[Y][X] == type) {
   80	                System.out.println("too long");
   81	                return false;
   82	            }
   83	
   84	            return true;
   85	        }
   86	        int dx = 1;
   87	        int dy = 1;
   88	        if(dir == 0)
   89	            dx = 0;
   90	        if(dir == 2)
   91	            dy = 0;
   92	        if(dir == 3)
   93	            dx = -1;
   94	        //if the tile before the first tile is of the same type, don't bother
   95	        if(count == 4 && X-dx >=0 && X-dx < cells && Y-dy >=0 && grid[Y-dy][X-dx] == type)
   96	            return false;
   97	        if(grid[Y][X] == type)
   98	            return recursiveCheckWin(type,X+dx,Y+dy,dir,count-1);
   99	        return false;
  100	    }
  101	
  102	    /** set state from given string
  103	     *
  104	     * @param data state of the game
  105	     */
  106	    public void setState(String data) {
  107	        String[] info = data.substring(6).split("]");
  108	        int turnInfo = Integer.parseInt(info[0]);
  109	        if(turnInfo == 0)
  110	            checkWinner();
  111	        else {
  112	            turn = turnInfo;







2012-03-17 16:37 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuGame.java Page 3


  113	            winner = 0;
  114	        }
  115	        String[] rows = info[1].split(";");
  116	        for(int i=0;i<cells;i++) {
  117	            String[] cols = rows[i].split(",");
  118	            for(int j=0;j<cells;j++) {
  119	                grid[i][j] = Integer.parseInt(cols[j]);
  120	            }
  121	        }
  122	        checkWinner();
  123	    }
  124	
  125	    /**
  126	     * generate string representing state of the game
  127	     * @return state of the game
  128	     */
  129	    public String getState() {
  130	        String state = "STATE[";
  131	        if(winner == 0)
  132	            state += turn+"]";
  133	        else
  134	            state += "0]";
  135	        for(int i=0;i<cells;i++) {
  136	            for(int j=0;j<cells;j++) {
  137	                state += grid[i][j];
  138	                if(j < cells-1)
  139	                    state +=",";
  140	            }
  141	            if(i<cells-1)
  142	                state += ";";
  143	        }
  144	        return state;
  145	    }
  146	}





























2012-03-17 16:38 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuPanel.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import javax.swing.*;
    4	import java.awt.*;
    5	import java.awt.event.ActionEvent;
    6	import java.awt.event.ActionListener;
    7	import java.awt.event.MouseEvent;
    8	import java.awt.event.MouseListener;
    9	
   10	/**
   11	 * GomokuPanel is a gamepanel which allows the user to play a game of gomoku, sending moves and displaying the current turn, and
   12	 * if applicable, the winner
   13	 *
   14	 * @author Joseph Colicchio
   15	 * @version for CS56, Choice Points, Winter 2012
   16	 */
   17	public class GomokuPanel extends GamePanel {
   18	    GomokuGame game;
   19	    JPanel menuButtons;
   20	
   21	    JButton playSpecButton;
   22	    LeaveButton leaveButton;
   23	    NewGameButton newGameButton;
   24	    SizesBox sizesBox;
   25	
   26	    public boolean isPlaying;
   27	
   28	    int offsetX, offsetY;
   29	    int margin;
   30	    double gridSize;
   31	    int panelSize;
   32	    int topMargin = 40;
   33	    int bottomMargin = 30;
   34	    
   35	    int cells = 9;
   36	
   37	    public GomokuPanel() {
   38	        setLayout(new BorderLayout());
   39	        menuButtons = new JPanel();
   40	//        menuButtons.setLayout(new BoxLayout(menuButtons, BoxLayout.X_AXIS));
   41	        add(BorderLayout.SOUTH, menuButtons);
   42	        playSpecButton = new PlaySpecButton();
   43	        playSpecButton.setAlignmentX(CENTER_ALIGNMENT);
   44	        leaveButton = new LeaveButton();
   45	        leaveButton.setAlignmentX(CENTER_ALIGNMENT);
   46	        newGameButton = new NewGameButton();
   47	        newGameButton.setAlignmentX(CENTER_ALIGNMENT);
   48	        newGameButton.setEnabled(false);
   49	        menuButtons.add(playSpecButton);
   50	        menuButtons.add(leaveButton);
   51	        menuButtons.add(newGameButton);
   52	
   53	        sizesBox = new SizesBox();
   54	        menuButtons.add(sizesBox);
   55	
   56	        game = new GomokuGame();







2012-03-17 16:38 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuPanel.java Page 2


   57	
   58	        GomokuCanvas canvas = new GomokuCanvas();
   59	        canvas.addMouseListener(canvas);
   60	        add(BorderLayout.CENTER, canvas);
   61	
   62	        isPlaying = false;
   63	    }
   64	
   65	    //TODO: be able to change grid size if 2 you are one of the two players BUT the game hasn't started yet
   66	        //sends a request to change size which is shot down by the server if the other player placed the first piece
   67	    //TODO: some kind of way to be notified when the game starts
   68	    //TODO: the init/size/state system is terrible, fix it
   69	
   70	    /**
   71	     * handle data from server
   72	     * @param string data
   73	     */
   74	    @Override
   75	    public void handleMessage(String string) {
   76	        System.out.println("handling as Gomoku: "+string);
   77	        if(string.indexOf("INIT;") == 0) {
   78	            game.init(9);
   79	        } else if(string.indexOf("STATE[") == 0) {
   80	            game.setState(string);
   81	        } else if(string.indexOf("MOVE[") == 0) {
   82	            String[] data = string.substring(5).split("]");
   83	            int pid = Integer.parseInt(data[0]);
   84	            String[] coords = data[1].split(",");
   85	            int X = Integer.parseInt(coords[0]);
   86	            int Y = Integer.parseInt(coords[1]);
   87	
   88	            game.grid[Y][X] = pid;
   89	            game.turn = 3-pid;
   90	        } else if(string.indexOf("PLAYERS;") == 0) {
   91	            String[] data = string.substring(8).split(",");
   92	            int pid1 = Integer.parseInt(data[0]);
   93	            int pid2 = Integer.parseInt(data[1]);
   94	            System.out.println(pid1+", "+JavaClient.javaClient.clients.size());
   95	            if(pid1 >= 0 && pid1 < JavaClient.javaClient.clients.size()) {
   96	                game.player1 = JavaClient.javaClient.clients.get(Integer.parseInt(data[0]));
   97	            } else
   98	                game.player1 = null;
   99	            if(pid2 >= 0 && pid2 < JavaClient.javaClient.clients.size())
  100	                game.player2 = JavaClient.javaClient.clients.get(Integer.parseInt(data[1]));
  101	            else
  102	                game.player2 = null;
  103	
  104	            //if the user is currently playing
  105	            if(pid1 == JavaClient.javaClient.id || pid2 == JavaClient.javaClient.id) {
  106	                isPlaying = true;
  107	                //if the game has two players, and is ready to go
  108	                if(game.player1 != null && game.player2 != null) {
  109	                    newGameButton.setEnabled(true);
  110	                    sizesBox.setEnabled(false);
  111	                } else {
  112	                    newGameButton.setEnabled(false);







2012-03-17 16:38 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuPanel.java Page 3


  113	                    sizesBox.setEnabled(true);
  114	                }
  115	            } else {
  116	                isPlaying = false;
  117	                newGameButton.setEnabled(false);
  118	                if(game.player1 != null && game.player2 != null)
  119	                    sizesBox.setEnabled(false);
  120	                else
  121	                    sizesBox.setEnabled(true);
  122	            }
  123	
  124	            if(isPlaying || game.player1 == null || game.player2 == null)
  125	                playSpecButton.setEnabled(true);
  126	            else
  127	                playSpecButton.setEnabled(false);
  128	        } else if(string.indexOf("WINNER;")==0) {
  129	            game.winner = Integer.parseInt(string.substring(7));
  130	        } else if(string.indexOf("SIZE;") == 0) {
  131	            int size = Integer.parseInt(string.substring(5));
  132	            game.init(size);
  133	            cells = size;
  134	            sizesBox.setSize(size);
  135	        }
  136	    }
  137	
  138	    /**
  139	     * canvas to draw game and allow interaction
  140	     */
  141	    class GomokuCanvas extends JPanel implements MouseListener {
  142	
  143	        @Override
  144	        public void paintComponent(Graphics g) {
  145	            super.paintComponent(g);
  146	
  147	            int totalWidth = getWidth();
  148	            int totalHeight = getHeight();
  149	
  150	            int gridHeight = totalHeight - topMargin - bottomMargin;
  151	            int gridWidth = totalWidth;
  152	            if(gridHeight < gridWidth) {
  153	                panelSize = gridHeight;
  154	                offsetX = (totalWidth-panelSize)/2;
  155	                offsetY = topMargin;
  156	            } else {
  157	                panelSize = gridWidth;
  158	                offsetX = 0;
  159	                offsetY = (gridHeight-panelSize)/2+topMargin;
  160	            }
  161	
  162	            gridSize = (double)(panelSize)/cells;
  163	            margin = (int)(panelSize/(33*cells))+1;
  164	
  165	            g.setColor(Color.white);
  166	            g.fillRect(0,0,getWidth(),getHeight());
  167	            if(!JavaClient.javaClient.connected || JavaClient.javaClient.clients == null)
  168	                return;







2012-03-17 16:38 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuPanel.java Page 4


  169	
  170	            g.setColor(Color.orange);
  171	            g.fillRect(offsetX,offsetY,panelSize,panelSize);
  172	            
  173	            g.setColor(new Color(0x333333));
  174	            for(int i=0;i<game.cells;i++) {
  175	                g.fillRect((int)(offsetX+gridSize*(i+0.5)-margin),(int)(offsetY+gridSize/2-margin),(int)(margin*2),(int)(panelSize-gridSize+2*margin));
  176	                g.fillRect((int)(offsetX+gridSize/2-margin),(int)(offsetY+gridSize*(i+0.5)-margin),(int)(panelSize-gridSize+2*margin),(int)(margin*2));
  177	            }
  178	
  179	            synchronized (game) {
  180	                for(int i=0;i<cells;i++) {
  181	                    for(int j=0;j<cells;j++) {
  182	                        int pid = game.grid[i][j];
  183	                        if(pid == 0)
  184	                            continue;
  185	
  186	                        Graphics2D g2d = (Graphics2D)g;
  187	                        if(pid == 1) {
  188	                            g.setColor(Color.DARK_GRAY);
  189	                        } else {
  190	                            g.setColor(Color.LIGHT_GRAY);
  191	                        }
  192	                        g.fillOval((int)(offsetX + j * gridSize + margin), (int)(offsetY + i * gridSize + margin),
  193	                                (int)(gridSize - 2*margin), (int)(gridSize - 2*margin));
  194	
  195	                    }
  196	                }
  197	
  198	                String readyState = "";
  199	                if(game.player1 != null) {
  200	                    g.setColor(Color.red);
  201	                    g.drawString("Player 1: "+game.player1.name,offsetX,15);
  202	                    g.setColor(Color.DARK_GRAY);
  203	                    g.fillOval(offsetX-25,offsetY-40,20,20);
  204	                } else
  205	                    readyState = "waiting for players";
  206	                if(game.player2 != null) {
  207	                    g.setColor(Color.blue);
  208	                    g.drawString("Player 2: "+game.player2.name,offsetX,35);
  209	                    g.setColor(Color.LIGHT_GRAY);
  210	                    g.fillOval(offsetX-25,offsetY-20,20,20);
  211	                } else
  212	                    readyState = "waiting for players";
  213	
  214	                if(readyState.equals("")) {
  215	                    if(game.winner == 1)
  216	                        readyState = game.player1.name+" wins!";
  217	                    else if(game.winner == 2)
  218	                        readyState = game.player2.name+" wins!";
  219	                    else if(game.turn == 1)
  220	                        readyState = game.player1.name+"'s turn";
  221	                    else
  222	                        readyState = game.player2.name+"'s turn";
  223	                }
  224	







2012-03-17 16:38 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuPanel.java Page 5


  225	                g.setColor(new Color(0x222222));
  226	                g.drawString(readyState,offsetX+panelSize/2-45,offsetY+panelSize+20);
  227	            }
  228	        }
  229	        @Override
  230	        public void mouseClicked(MouseEvent mouseEvent){ }
  231	        @Override
  232	        public void mousePressed(MouseEvent mouseEvent){
  233	            if(!isPlaying)
  234	                return;
  235	
  236	            //To change body of implemented methods use File | Settings | File Templates.
  237	            int mX = mouseEvent.getX();
  238	            int mY = mouseEvent.getY();
  239	            int dX = mX-offsetX;
  240	            int dY = mY-offsetY;
  241	            int cellX = (dX*cells/panelSize);
  242	            int cellY = (dY*cells/panelSize);
  243	            System.out.println(mX+", "+mY+", "+dX+", "+dY+", "+cellX+", "+cellY);
  244	            if(cellX >= 0 && cellX < cells && cellY >= 0 && cellY < cells) {
  245	                JavaClient.javaClient.sendMessage("MOVE;" + cellX + "," + cellY);
  246	            }
  247	        }
  248	        @Override
  249	        public void mouseReleased(MouseEvent mouseEvent){ }
  250	        @Override
  251	        public void mouseEntered(MouseEvent mouseEvent){ }
  252	        @Override
  253	        public void mouseExited(MouseEvent mouseEvent){ }
  254	    }
  255	
  256	    /**
  257	     * let player play or spectate
  258	     */
  259	    class PlaySpecButton extends JButton implements ActionListener{
  260	        public boolean playing;
  261	        public PlaySpecButton() {
  262	            super("Play");
  263	            playing = false;
  264	            addActionListener(this);
  265	        }
  266	
  267	        @Override
  268	        public void actionPerformed(ActionEvent actionEvent){
  269	            if(playing) {
  270	                JavaClient.javaClient.sendMessage("MSG;/spec");
  271	                setText("Play");
  272	                playing = false;
  273	            } else {
  274	                JavaClient.javaClient.sendMessage("MSG;/play");
  275	                setText("Spectate");
  276	                playing = true;
  277	            }
  278	        }
  279	    }
  280	







2012-03-17 16:38 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuPanel.java Page 6


  281	    /**
  282	     * let player leave game for lobby
  283	     */
  284	    class LeaveButton extends JButton implements ActionListener{
  285	        public LeaveButton() {
  286	            super("Leave");
  287	            addActionListener(this);
  288	        }
  289	
  290	        @Override
  291	        public void actionPerformed(ActionEvent actionEvent){
  292	            JavaClient.javaClient.sendMessage("MSG;/join lobby");
  293	        }
  294	    }
  295	
  296	    /**
  297	     * let player in game start new game
  298	     */
  299	    class NewGameButton extends JButton implements ActionListener {
  300	        public NewGameButton() {
  301	            super("New Game");
  302	            addActionListener(this);
  303	        }
  304	
  305	        @Override
  306	        public void actionPerformed(ActionEvent actionEvent) {
  307	            JavaClient.javaClient.sendMessage("MSG;/newgame");
  308	        }
  309	    }
  310	
  311	    /**
  312	     * let client change size of board
  313	     */
  314	    class SizesBox extends JComboBox implements ActionListener {
  315	        private boolean hideAction;
  316	
  317	        public SizesBox() {
  318	            super(new String[]{"9x9", "13x13", "17x17"});
  319	            hideAction = false;
  320	            addActionListener(this);
  321	        }
  322	        
  323	        public void setSize(int n) {
  324	            int index = (n-9)/4;
  325	            synchronized (this) {
  326	                hideAction = true;
  327	                setSelectedIndex(index);
  328	                hideAction = false;
  329	            }
  330	        }
  331	
  332	        public void actionPerformed(ActionEvent e) {
  333	            if(hideAction)
  334	                return;
  335	            String text = (String)getSelectedItem();
  336	            int size = 9;







2012-03-17 16:38 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuPanel.java Page 7


  337	            if(text.equals("9x9"))
  338	                size = 9;
  339	            else if(text.equals("13x13"))
  340	                size = 13;
  341	            else if(text.equals("17x17"))
  342	                size = 17;
  343	            JavaClient.javaClient.sendMessage("SIZE;"+size);
  344	        }
  345	    }
  346	}





















































2012-03-17 16:40 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuService.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * GomokuService is a server-side service that allows clients to send moves to the server's copy of a gomoku game
    5	 *
    6	 * @author Joseph Colicchio
    7	 * @version for CS56, Choice Points, Winter 2012
    8	 */
    9	
   10	public class GomokuService extends TwoPlayerGameService {
   11	    public GomokuGame gameData;
   12	
   13	    public ClientConnect player1;
   14	    public ClientConnect player2;
   15	
   16	    public boolean gameStarted;
   17	
   18	    /**
   19	     * start gomoku service with id ID
   20	     * @param ID id of service
   21	     */
   22	    public GomokuService(int ID) {
   23	        super(ID);
   24	        gameData = new GomokuGame();
   25	        type = 2;
   26	        name = "Gomoku";
   27	    }
   28	
   29	    /**
   30	     * initialize with size
   31	     * @param SIZE size of board to init with
   32	     */
   33	    public void init(int SIZE) {
   34	        gameData.init(SIZE);
   35	        broadcastData("SIZE;"+SIZE);
   36	    }
   37	
   38	    /**
   39	     * default size is 9
   40	     */
   41	    public void init() {
   42	        gameData.init(9);
   43	        broadcastData("INIT;");
   44	    }
   45	
   46	    /**
   47	     * add client to service
   48	     * @param client clientconnect object to add
   49	     */
   50	    public void addClient(ClientConnect client) {
   51	        super.addClient(client);
   52	        client.sendMessage("SIZE;"+gameData.cells);
   53	    }
   54	
   55	    /**
   56	     * set client as a player







2012-03-17 16:40 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuService.java Page 2


   57	     * @param client client to play
   58	     */
   59	    public void playClient(ClientConnect client) {
   60	        if(player1 == null) {
   61	            player1 = client;
   62	            gameData.player1 = client.client;
   63	        } else if(player2 == null && player1 != client) {
   64	            player2 = client;
   65	            gameData.player2 = client.client;
   66	            gameStarted = true;
   67	            System.out.println("ready to play: "+player1.client.id+" vs "+player2.client.id);
   68	            gameData.init(gameData.cells);
   69	        }
   70	
   71	        updateAll();
   72	    }
   73	
   74	    //if a client was a player, spec him, and then probably stop the game
   75	
   76	    /**
   77	     * set playing client as spectator
   78	     * @param client client to spectate
   79	     */
   80	    public void specClient(ClientConnect client) {
   81	        if(player1 != client && player2 != client)
   82	            return;
   83	        if(player1 == client) {
   84	            player1 = player2;
   85	            gameData.player1 = gameData.player2;
   86	            player2 = null;
   87	            gameData.player2 = null;
   88	            gameStarted = false;
   89	            gameData.init(gameData.cells);
   90	        }
   91	        if(player2 == client) {
   92	            player2 = null;
   93	            gameData.player2 = null;
   94	            gameStarted = false;
   95	            gameData.init(gameData.cells);
   96	        }
   97	
   98	        updateAll();
   99	    }
  100	
  101	    //get move from player, if it's their turn
  102	
  103	    /**
  104	     * handle info from client
  105	     * @param client the client sending the data
  106	     * @param string data to handle
  107	     */
  108	    public void handleData(ClientConnect client, String string) {
  109	        if(string.indexOf("PLAY;") == 0)
  110	            playClient(client);
  111	        else if(string.indexOf("SPEC;") == 0)
  112	            specClient(client);







2012-03-17 16:40 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuService.java Page 3


  113	        else if(string.indexOf("SIZE;") == 0) {
  114	            int size = Integer.parseInt(string.substring(5));
  115	            init(size);
  116	        } else if(string.indexOf("MSG;") == 0) {
  117	            String message = string.substring(4);
  118	            if(message.indexOf("/play")==0) {
  119	                playClient(client);
  120	            } else if(message.indexOf("/spec") == 0) {
  121	                specClient(client);
  122	            } else if(message.indexOf("/newgame") == 0) {
  123	                if(client == player1 || client == player2)
  124	                    init(gameData.cells);
  125	            } else
  126	                super.handleData(client, string);
  127	        }
  128	
  129	        if(!gameStarted || gameData.winner > 0)
  130	            return;
  131	        System.out.println(gameData.turn+", "+client.client.id+", "+player1.client.id+":"+player2.client.id);
  132	        if(gameData.turn == 1 && client != player1)
  133	            return;
  134	        if(gameData.turn == 2 && client != player2)
  135	            return;
  136	
  137	        //this is an optional setting, some games may use it, eventually implement rule checkboxes
  138	        //TODO: disallow moves that result in forming two 3's, (unblocked?), or 2 4's, blocked or unblocked
  139	        if(string.indexOf("MOVE;") == 0) {
  140	            System.out.println("got move command from "+client.client.id+": "+string);
  141	            String[] data = string.substring(5).split(",");
  142	            int X = Integer.parseInt(data[0]);
  143	            int Y = Integer.parseInt(data[1]);
  144	
  145	            if(gameData.grid[Y][X] != 0)
  146	                return;
  147	
  148	            gameData.grid[Y][X] = gameData.turn;
  149	            broadcastData("MOVE[" + gameData.turn + "]" + X + "," + Y);
  150	            if(gameData.checkWinner())
  151	                broadcastData("WINNER;"+gameData.winner);
  152	            gameData.turn = 3-gameData.turn;
  153	        }
  154	    }
  155	
  156	    //sends the state of the game to a player
  157	
  158	    /**
  159	     * send state of the game to client
  160	     * @param client client to send state to
  161	     */
  162	    public void sendGameState(ClientConnect client) {
  163	        if(client == null)
  164	            return;
  165	        synchronized (client) {
  166	            client.sendMessage(gameData.getState());
  167	            String players = "PLAYERS;";
  168	            if(gameData.player1 != null)







2012-03-17 16:40 src/edu/ucsb/cs56/W12/jcolicchio/issue535/GomokuService.java Page 4


  169	                players += gameData.player1.id;
  170	            else
  171	                players += "-1";
  172	            players += ",";
  173	            if(gameData.player2 != null)
  174	                players += gameData.player2.id;
  175	            else
  176	                players += "-1";
  177	
  178	            client.sendMessage(players);
  179	        }
  180	    }
  181	}


















































2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import java.io.*;
    4	import java.net.*;
    5	import java.awt.*;
    6	import java.awt.event.*;
    7	import java.util.ArrayList;
    8	import javax.swing.*;
    9	
   10	/**
   11	 * JavaClient is the main runnable client-side application, it allows users to connect to a server on a specific port
   12	 * and chat with other connected users, as well as play games like tic tac toe, gomoku, and chess with them
   13	 * it is composed of a user list, a message box, input box and send button for chatting, and a panel area to display
   14	 * the lobby or current game
   15	 *
   16	 * @author Joseph Colicchio
   17	 * @version for CS56, Choice Points, Winter 2012
   18	 */
   19	
   20	//start a java message client that tries to connect to a server at localhost:X
   21	public class JavaClient implements KeyListener {
   22	    public static JavaClient javaClient;
   23	
   24	    Socket sock;
   25	    InputStreamReader stream;
   26	    BufferedReader reader;
   27	    PrintWriter writer;
   28	
   29	    ArrayList<ClientObject> clients;
   30	    ArrayList<Integer> services;
   31	    
   32	    ArrayList<Message> messages;
   33	
   34	    JFrame frame;
   35	    Container container;
   36	    GamePanel canvas;//the actual canvas currently being used by the gui
   37	    GamePanel canvasRef;//a reference to the current canvas being used by the game logic
   38	    JTextField inputBox;
   39	    JButton sendButton;
   40	    JEditorPane outputBox;
   41	
   42	    JList userList;
   43	    DefaultListModel listModel;
   44	
   45	    int id;
   46	    String name;
   47	    int location;
   48	
   49	    boolean[] Keys;
   50	    
   51	    InputReader thread;
   52	    RefreshThread refreshThread;
   53	    boolean connected;
   54	
   55	    public static void main(String [] args) {
   56	        javaClient = new JavaClient();







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 2


   57	    }
   58	
   59	    public JavaClient() {
   60	        Res.init(this.getClass());
   61	        frame = new JFrame("Java Games Online");
   62	        frame.setSize(640, 512);
   63	        frame.setMinimumSize(new Dimension(480,512));
   64	        frame.addWindowListener(new WindowAdapter() {
   65	            public void windowClosing(WindowEvent winEvt) {
   66	                if(thread != null)
   67	                    thread.running = false;
   68	                if(connected)
   69	                    sendMessage("DCON;Window Closed");
   70	
   71	                System.exit(0);
   72	            }
   73	        });
   74	
   75	        
   76	        container = frame.getContentPane();
   77	        canvas = new OfflinePanel(JavaServer.IP_ADDR,JavaServer.PORT);
   78	        canvasRef = canvas;
   79	        container.add(BorderLayout.CENTER,canvas);
   80	
   81	        JPanel southPanel = new JPanel(new BorderLayout());
   82	        container.add(BorderLayout.SOUTH, southPanel);
   83	
   84	        SendListener listener = new SendListener();
   85	        inputBox = new JTextField();
   86	        inputBox.addActionListener(listener);
   87	        sendButton = new JButton("Send");
   88	        sendButton.addActionListener(listener);
   89	        southPanel.setFocusable(true);
   90	        canvas.setFocusable(true);
   91	
   92	        canvas.addKeyListener(this);
   93	        canvas.addMouseListener(canvas);
   94	        inputBox.addKeyListener(this);
   95	
   96	        southPanel.add(BorderLayout.EAST, sendButton);
   97	        southPanel.add(BorderLayout.CENTER, inputBox);
   98	
   99	        listModel = new DefaultListModel();
  100	
  101	
  102	        userList = new JList(listModel);
  103	        MouseListener mouseListener = new MouseAdapter() {
  104	            public void mouseClicked(MouseEvent e) {
  105	                if (e.getClickCount() == 2) {
  106	                    int index = userList.locationToIndex(e.getPoint());
  107	                    //follow player into game
  108	                    Username user = (Username)(listModel.getElementAt(index));
  109	                    if(user != null)
  110	                        sendMessage("MSG;/follow "+user.name);
  111	                }
  112	            }







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 3


  113	        };
  114	        userList.addMouseListener(mouseListener);
  115	        userList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  116	        userList.setLayoutOrientation(JList.VERTICAL);
  117	        userList.setVisibleRowCount(-1);
  118	        userList.setCellRenderer(new MyCellRenderer());
  119	
  120	        JScrollPane userScroll = new JScrollPane(userList);
  121	        userScroll.setAlignmentX(JScrollPane.LEFT_ALIGNMENT);
  122	        JPanel userPanel = new JPanel();
  123	        userPanel.setLayout(new BorderLayout());
  124	        container.add(BorderLayout.WEST, userPanel);
  125	        userPanel.add(BorderLayout.CENTER,userScroll);
  126	        FollowButton followButton = new FollowButton();
  127	        MessageButton messageButton = new MessageButton();
  128	        
  129	        JPanel menuPanel = new JPanel();
  130	        menuPanel.setLayout(new BoxLayout(menuPanel,BoxLayout.X_AXIS));
  131	        menuPanel.add(followButton);
  132	        menuPanel.add(Box.createHorizontalGlue());
  133	        menuPanel.add(messageButton);
  134	        userPanel.add(BorderLayout.SOUTH,menuPanel);
  135	        userScroll.setPreferredSize(new Dimension(160,100));
  136	
  137	        outputBox = new JEditorPane("text/html", "");
  138	        JScrollPane outputScroll = new JScrollPane(outputBox);
  139	        outputBox.setEditable(false);
  140	        southPanel.add(BorderLayout.NORTH, outputScroll);
  141	        outputScroll.setPreferredSize(new Dimension(100, 100));
  142	
  143	        frame.setVisible(true);
  144	
  145	        Keys = new boolean[255];
  146	        for(int i=0;i<255;i++)
  147	            Keys[i] = false;
  148	
  149	        //TODO: use the standardized list!!
  150	
  151	        location = -1;
  152	    }
  153	
  154	    /** followbutton allows users to follow their friends into the game they're playing
  155	     * this can also be achieved by double-clicking on a name in the user list
  156	     */
  157	    class FollowButton extends JButton implements  ActionListener {
  158	        public FollowButton() {
  159	            super("Follow");
  160	            addActionListener(this);
  161	        }
  162	
  163	        @Override
  164	        public void actionPerformed(ActionEvent e) {
  165	            Username user = (Username)userList.getSelectedValue();
  166	            if(user != null)
  167	               sendMessage("MSG;/follow "+user.name);
  168	        }







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 4


  169	    }
  170	
  171	    /** messagebutton fills the input box with a command to send the specified user a message
  172	     *
  173	     */
  174	    class MessageButton extends JButton implements  ActionListener {
  175	        public MessageButton() {
  176	            super("Message");
  177	            addActionListener(this);
  178	        }
  179	
  180	        @Override
  181	        public void actionPerformed(ActionEvent e) {
  182	            Username user = (Username)userList.getSelectedValue();
  183	            if(user == null)
  184	                return;
  185	
  186	            inputBox.setText("/msg " + user.name + " ");
  187	            //give inputbox focus
  188	            inputBox.requestFocus();
  189	        }
  190	    }
  191	
  192	
  193	    public void init() {
  194	        clients = new ArrayList<ClientObject>();
  195	        services = new ArrayList<Integer>();
  196	        messages = new ArrayList<Message>();
  197	    }
  198	
  199	    /** updateClients updates the client list with the names and locations of everyone on the server
  200	     * should be called whenever a user joins, leaves, or changes locations
  201	     */
  202	    public void updateClients() {
  203	        SwingUtilities.invokeLater(
  204	            new Runnable() {
  205	                public void run() {
  206	                    synchronized (clients) {
  207	                        listModel.clear();
  208	                        if(location < 0)
  209	                            return;
  210	                        listModel.addElement(new Username(name,null,2));
  211	                        for(int i=clients.size()-1;i>=0;i--) {
  212	                            ClientObject client = clients.get(i);
  213	                            if(client != null) {
  214	                                if(client.id == id)
  215	                                    continue;
  216	                                if(client.location == location || services.size() <= client.location)
  217	                                    listModel.insertElementAt((new Username(client.name,null,0)),1);
  218	                                else {
  219	//                                    System.out.println(client.location+", "+serviceList.size()+", "+services.size());
  220	                                    listModel.addElement(new Username(client.name," ("+client.location+":"+Service.getGameType(services.get(client.location))+")",1));
  221	                                }
  222	                            }
  223	                        }
  224	                    }







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 5


  225	                }
  226	            }
  227	        );
  228	    }
  229	
  230	    /** updateMessages updates the message box, and then scrolls down to the bottom to see the most recent
  231	     * message. should be called whenever a new message is received
  232	     */
  233	    public void updateMessages() {
  234	        SwingUtilities.invokeLater(
  235	            new Runnable() {
  236	                public void run() {
  237	                    String content = "";
  238	                    for(int i=0;i<messages.size();i++) {
  239	                        content += messages.get(i).toString() + "<br>";
  240	                    }
  241	                    outputBox.setText(content);
  242	                    int caret = outputBox.getDocument().getLength()-1;
  243	                    if(caret > 0)
  244	                        outputBox.setCaretPosition(caret);
  245	                }
  246	            }
  247	        );
  248	    }
  249	
  250	    /** connect is called when the player enters an IP and port number, and clicks connect
  251	     * it attempts to connect the player to the associated running server if it exists
  252	     * @param ip - the ip address string to connect to
  253	     * @param port - the port number
  254	     */
  255	    public void connect(String ip, int port) {
  256	        if(connected)
  257	            return;
  258	        try {
  259	            System.out.println("Connecting to "+ip+":"+port);
  260	            sock = new Socket(ip,port);
  261	            System.out.println("Connected");
  262	            connected = true;
  263	            init();
  264	            stream = new InputStreamReader(sock.getInputStream());
  265	            reader = new BufferedReader(stream);
  266	            writer = new PrintWriter(sock.getOutputStream());
  267	            sendMessage("ACKNOWLEDGE ME!");
  268	            thread = new InputReader();
  269	            thread.start();
  270	            refreshThread = new RefreshThread(this);
  271	            refreshThread.start();
  272	        } catch(IOException ex) {
  273	            ex.printStackTrace();
  274	            System.out.println("unable to connect");
  275	            //System.out.println("quitting...");
  276	            //System.exit(1);
  277	        }
  278	    }
  279	
  280	    //public void update() {







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 6


  281	    //    for(int i=0;i<clients.size();i++)
  282	    //        if(clients.get(i) != null)
  283	    //            clients.get(i).update();
  284	    //}
  285	
  286	    /** handleMessage is passed a string which has been sent from the server
  287	     * it attempts to resolve the request but may forward it to the active game panel, if applicable
  288	     * it manages things like users connecting, disconnecting, receiving private messages, nick changes, etc
  289	     * whereas the game panel handles data regarding the current game
  290	     * @param string the data from the server to handle
  291	     */
  292	    public void handleMessage(String string) {
  293	        if(string.indexOf("CON;") == 0) {
  294	            int pid = Integer.parseInt(string.substring(4));
  295	            System.out.println("Client "+pid+" has connected");
  296	            while(clients.size() <= pid)
  297	                clients.add(null);
  298	            if(clients.get(pid) == null)
  299	                clients.set(pid, new ClientObject(pid));
  300	            else
  301	                sendMessage("INFO;");
  302	            messages.add(new Message(clients.get(pid).name+" connected", "Server",true,false));
  303	            updateClients();
  304	            updateMessages();
  305	        } else if(string.indexOf("DCON[") == 0) {
  306	            String[] data = string.substring(5).split("]");
  307	            int pid = Integer.parseInt(data[0]);
  308	            System.out.println("Client " + pid + " has disconnected: " + data[1]);
  309	            if(clients.size() > pid && clients.get(pid) != null) {
  310	                messages.add(new Message(clients.get(pid).name + " disconnected: "+data[1], "Server", true, false));
  311	                clients.set(pid, null);
  312	            }
  313	            updateClients();
  314	            updateMessages();
  315	            if(pid == id)
  316	                thread.running = false;
  317	        } else if(string.indexOf("MSG[") == 0) {
  318	            String[] data = string.substring(4).split("]");
  319	            int pid = Integer.parseInt(data[0]);
  320	            if(clients.size() <= pid || clients.get(pid) == null)
  321	                return;
  322	            String msg = string.substring(4+data[0].length()+1);
  323	            System.out.println("Client "+pid+" said "+msg);
  324	            if(clients.size() > pid) {
  325	                messages.add(new Message(msg,clients.get(pid).name,false,false));
  326	                updateMessages();
  327	            }
  328	        } else if(string.indexOf("PMSG[") == 0) {
  329	            String[] data = string.substring(5).split("]");
  330	            int pid = Integer.parseInt(data[0]);
  331	            String msg = string.substring(5+data[0].length()+1);
  332	            System.out.println("Client "+pid+" privately said "+msg);
  333	            if(clients.size() > pid) {
  334	                messages.add(new Message(msg,clients.get(pid).name, true, false));
  335	                updateMessages();
  336	            }







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 7


  337	        } else if(string.indexOf("RMSG[") == 0) {
  338	            String[] data = string.substring(5).split("]");
  339	            int pid = Integer.parseInt(data[0]);
  340	            String msg = string.substring(5+data[0].length()+1);
  341	            if(clients.size() > pid) {
  342	                messages.add(new Message(msg,clients.get(pid).name,true,true));
  343	                updateMessages();
  344	            }
  345	        } else if(string.indexOf("SMSG;") == 0) {
  346	            String msg = string.substring(5);
  347	            if(msg != null && msg.length() > 0) {
  348	                messages.add(new Message(msg,"Server",true,false));
  349	                updateMessages();
  350	            }
  351	        } else if(string.indexOf("ID;") == 0) {
  352	            id = Integer.parseInt(string.substring(3));
  353	            if(name == null)
  354	                name = "User"+id;
  355	
  356	            sendMessage("CON;");
  357	            sendMessage("NAME;"+name);
  358	            sendMessage("INFO;");
  359	            System.out.println(location);
  360	        } else if(string.indexOf("ALL;") == 0) {
  361	            String[] connected = string.substring(4).split(";");
  362	            for(int i=0;i<connected.length;i++) {
  363	                String[] info = connected[i].split(",");
  364	                if(clients.size() <= i)
  365	                    clients.add(null);
  366	                if(connected[i].equals(","))
  367	                    continue;
  368	                if(info[0].equals("")) {
  369	                    if(clients.get(i) != null)
  370	                        clients.set(i, null);
  371	                } else {
  372	                    clients.set(i, new ClientObject(i, info[0], Integer.parseInt(info[1])));
  373	                    if(id == i)
  374	                        changeLocation(Integer.parseInt(info[1]));
  375	                }
  376	            }
  377	            //the problem is here, we need to have something else removing the clients from the list and re-adding them
  378	            //otherwise when the thing redraws, it'll freak out
  379	            updateClients();
  380	        } else if(string.indexOf("SERV;") == 0) {
  381	            String[] serv = string.substring(5).split(",");
  382	            for(int i=0;i<serv.length;i++) {
  383	                if(services.size() <= i)
  384	                    services.add(null);
  385	                services.set(i, Integer.parseInt(serv[i]));
  386	            }
  387	            updateClients();
  388	            changeLocation(location);
  389	        } else if(string.indexOf("NEW;") == 0) {
  390	            services.add(Integer.parseInt(string.substring(4)));
  391	        } else if(string.indexOf("NAME[") == 0) {
  392	            String[] data = string.substring(5).split("]");







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 8


  393	            int pid = Integer.parseInt(data[0]);
  394	            String pname = data[1];
  395	            if(clients.size() <= pid)
  396	                return;
  397	            if(clients.get(pid) == null)
  398	                clients.set(pid, new ClientObject(id, pname, 0));
  399	            //messages.add(new edu.ucsb.cs56.W12.jcolicchio.issue535.Message(clients.get(pid).name+" changed his name to "+pname, "Server",true,false,clients.get(0).getColor()));
  400	            clients.get(pid).name = pname;
  401	            if(pid == id)
  402	                name = pname;
  403	            updateClients();
  404	            updateMessages();
  405	        } else if(string.indexOf("MOVED[") == 0) {
  406	            String[] data = string.substring(6).split("]");
  407	            int pid = Integer.parseInt(data[0]);
  408	            clients.get(pid).location = Integer.parseInt(data[1]);
  409	            if(pid == id) {
  410	                changeLocation(clients.get(id).location);
  411	            }
  412	            updateClients();
  413	            updateMessages();
  414	        }
  415	        canvasRef.handleMessage(string);
  416	    }
  417	
  418	    /** changes the location of the client, in order to generate a service panel associated with
  419	     * that location to start interacting with the specified service
  420	     * @param L the service id number
  421	     */
  422	    public void changeLocation(int L) {
  423	        if(location == L)
  424	            return;
  425	        location = L;
  426	        if(location == -1) {
  427	            canvasRef = new OfflinePanel(JavaServer.IP_ADDR,JavaServer.PORT);
  428	        } else {
  429	
  430	            int serviceType = services.get(location);
  431	            if(serviceType == 0)
  432	                canvasRef = new LobbyPanel();
  433	            else if(serviceType == 1)
  434	                canvasRef = new TicTacToePanel();
  435	            else if(serviceType == 2)
  436	                canvasRef = new GomokuPanel();
  437	            else if(serviceType == 3)
  438	                canvasRef = new ChessPanel();
  439	        }
  440	
  441	        SwingUtilities.invokeLater(
  442	            new Runnable() {
  443	                public void run() {
  444	                    messages = new ArrayList<Message>();
  445	                    //updateMessages();
  446	                    container.remove(canvas);
  447	                    canvas = canvasRef;
  448	                    container.add(BorderLayout.CENTER, canvas);







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 9


  449	                    canvas.addMouseListener(canvas);
  450	                    //frame.validate();
  451	                    container.validate();
  452	                }
  453	            }
  454	        );
  455	    }
  456	
  457	    /** sends a message to the server, which might be a request for information, game data,
  458	     * or a literal message to be broadcast to all users in the message box
  459	     * @param string a string of data to send to the server
  460	     */
  461	    public void sendMessage(String string) {
  462	        writer.println(string);
  463	        writer.flush();
  464	    }
  465	
  466	    @Override
  467	    public void keyTyped(KeyEvent keyEvent){ }
  468	
  469	    @Override
  470	    public void keyPressed(KeyEvent keyEvent){
  471	        Keys[keyEvent.getKeyCode()] = true;
  472	    }
  473	
  474	    @Override
  475	    public void keyReleased(KeyEvent keyEvent){
  476	        Keys[keyEvent.getKeyCode()] = false;
  477	    }
  478	
  479	    /** listens for the send button's action and sends a message, if connected
  480	     *
  481	     */
  482	    class SendListener implements ActionListener {
  483	        public SendListener() {
  484	
  485	        }
  486	
  487	        public void actionPerformed(ActionEvent event) {
  488	            String message = inputBox.getText();
  489	            if(message.length() == 0)
  490	                return;
  491	
  492	            inputBox.setText("");
  493	            if(connected) {
  494	                sendMessage("MSG;"+message);
  495	            }
  496	        }
  497	    }
  498	
  499	    /** input reader waits for data from the server and forwards it to the client
  500	     *
  501	     */
  502	    class InputReader extends Thread implements Runnable {
  503	        public boolean running;
  504	        public void run() {







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 10


  505	            String line;
  506	            running = true;
  507	            try {
  508	                while(running && (line = reader.readLine()) != null) {
  509	                    System.out.println("incoming... "+line);
  510	                    handleMessage(line);
  511	                }
  512	            } catch(SocketException ex) {
  513	                ex.printStackTrace();
  514	                System.out.println("lost connection to server...");
  515	            } catch(Exception ex) {
  516	                ex.printStackTrace();
  517	                System.out.println("crashed for some other reason, disconnecting...");
  518	                writer.println("DCON;"+id);
  519	                writer.flush();
  520	            }
  521	
  522	            try{
  523	                sock.close();
  524	            }catch(IOException e){
  525	                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
  526	            }
  527	            connected = false;
  528	            outputBox.setText("");
  529	            updateClients();
  530	            changeLocation(-1);
  531	            System.out.println("quitting, cause thread ended");
  532	            //System.exit(0);
  533	        }
  534	    }
  535	
  536	}
  537	
  538	/** renders usernames with bold or italics
  539	 * useful when a user is in another location
  540	 * or to highlight the client's username
  541	 */
  542	class MyCellRenderer extends DefaultListCellRenderer {
  543	
  544	    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
  545	        Component c = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
  546	
  547	        Username user = (Username)value;
  548	        if (user.style == 2) {// <= put your logic here
  549	            c.setFont(c.getFont().deriveFont(Font.BOLD));
  550	        } else if(user.style == 1) {
  551	            c.setFont(c.getFont().deriveFont(Font.ITALIC));
  552	        } else {
  553	            c.setFont(c.getFont().deriveFont(Font.PLAIN));
  554	        }
  555	        return c;
  556	    }
  557	}
  558	
  559	/**
  560	 * refresh thread constantly repaints the application







2012-03-17 16:08 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaClient.java Page 11


  561	 */
  562	class RefreshThread extends Thread implements Runnable {
  563	    public boolean running;
  564	    JavaClient javaClient;
  565	    public RefreshThread(JavaClient client) {
  566	        running = false;
  567	        javaClient = client;
  568	    }
  569	
  570	    public void run() {
  571	        running = true;
  572	        while(running) {
  573	            //javaClient.update();
  574	            SwingUtilities.invokeLater(
  575	                    new Runnable() {
  576	                        public void run() {
  577	                            javaClient.canvas.repaint();
  578	                        }
  579	                    }
  580	            );
  581	            try {
  582	                Thread.sleep(50);
  583	            } catch(InterruptedException e) {
  584	                e.printStackTrace();
  585	                System.out.println("refresh thread broke");
  586	            }
  587	        }
  588	    }
  589	}


































2012-03-17 20:17 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaServer.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import javax.swing.*;
    4	import javax.swing.text.Utilities;
    5	import java.awt.*;
    6	import java.awt.event.ActionEvent;
    7	import java.awt.event.ActionListener;
    8	import java.io.*;
    9	import java.net.*;
   10	import java.util.ArrayList;
   11	import java.util.Enumeration;
   12	
   13	/**
   14	 * JavaServer is the main server-side application, can be run without gui by using a port number as a single argument
   15	 * on the command line. keeps track of clients connected and broadcasts data to one or multiple clients by setting up
   16	 * clientconnect objects for each of them and keeping a list of users connected.
   17	 * clientconnect handles server-related input from users and, if necessary, can query the server to find users by name
   18	 * or an available, open game service
   19	 *
   20	 * @author Joseph Colicchio
   21	 * @version for CS56, Choice Points, Winter 2012
   22	 */
   23	
   24	//start a java message server that listens for connections to port X and then connects the client 
   25	public class JavaServer{
   26	    //this belongs to the server itself, independent of the chat standards
   27	    public static ArrayList<ClientConnect> clients;
   28	    public static ArrayList<Service> services;
   29	    public static LobbyService lobby;
   30	    
   31	    public JTextField port_box;
   32	    public ConnectButton connectButton;
   33	    public JLabel status;
   34	    public boolean running;
   35	
   36	    //this could go in either, it's used mostly for the chat
   37	    public static ArrayList<String> bannedList;
   38	
   39	    //public static final String IP_ADDR = "184.189.233.37"; // home
   40	    //public static final String IP_ADDR = "184.189.240.201"; // ro's house
   41	    //public static final String IP_ADDR = "128.111.57.217";
   42	    //public static final String IP_ADDR = "128.111.57.217";
   43	    //public static final String IP_ADDR = "169.231.108.15"; // temporary wireless
   44	    public static final String IP_ADDR = "127.0.0.1"; // localhost
   45	    public static final int PORT = 12345;
   46	
   47	    public static boolean connected;
   48	    public static JavaServer javaServer;
   49	    public MainThread mainThread;
   50	    public String runningOn;
   51	    public int portNum;
   52	    public static boolean nogui;
   53	
   54	    public static void main(String [] args) {
   55	        if(args.length > 0) {
   56	            try {







2012-03-17 20:17 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaServer.java Page 2


   57	                int portNum = Integer.parseInt(args[0]);
   58	                nogui = true;
   59	                javaServer = new JavaServer();
   60	                javaServer.connect(portNum);
   61	            } catch(Exception ex) {
   62	                System.out.println("bad port: "+args[0]);
   63	                System.exit(1);
   64	            }
   65	        } else
   66	            javaServer = new JavaServer();
   67	    }
   68	
   69	    /**
   70	     * start server on specified port
   71	     * @param port port number to bind to
   72	     */
   73	    public void connect(int port) {
   74	        try {
   75	            URL ipGetter = new URL(" http://api.externalip.net/ip/");
   76	            BufferedReader ip = new BufferedReader(new InputStreamReader(ipGetter.openStream()));
   77	            runningOn = ip.readLine();
   78	            System.out.println(runningOn);
   79	        } catch(Exception ex) {
   80	            ex.printStackTrace();
   81	        }
   82	        mainThread = new MainThread(port);
   83	        mainThread.start();
   84	    }
   85	
   86	    /**
   87	     * gracefully stop server for whatever reason
   88	     */
   89	    public void stop() {
   90	        running = false;
   91	        try {
   92	            Socket socket = new Socket("127.0.0.1",portNum);
   93	        } catch(Exception ex) {
   94	            ex.printStackTrace();
   95	            if(!nogui)
   96	                javaServer.status.setText("Couldn't stop");
   97	        }
   98	    }
   99	    
  100	    public JavaServer() {
  101	        if(nogui)
  102	            return;
  103	        JFrame mainFrame = new JFrame();
  104	        Container container = mainFrame.getContentPane();
  105	        JPanel main = new JPanel();
  106	        //main.setLayout(new BorderLayout());
  107	        container.add(BorderLayout.CENTER, main);
  108	        port_box = new JTextField();
  109	        port_box.setText(PORT + "");
  110	        main.add(port_box);
  111	        connectButton = new ConnectButton();
  112	        main.add(connectButton);







2012-03-17 20:17 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaServer.java Page 3


  113	        status = new JLabel();
  114	        main.add(status);
  115	        //mainFrame.pack();
  116	        mainFrame.setSize(200,100);
  117	        mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  118	        mainFrame.setVisible(true);
  119	    }
  120	
  121	    /**
  122	     * update gui with number of clients
  123	     */
  124	    public static void updateServerGUI() {
  125	        if(nogui)
  126	            return;
  127	        if(javaServer.running)
  128	            javaServer.status.setText(javaServer.runningOn+", "+clients.size()+" user"+(clients.size()!=1?"s":""));
  129	        else
  130	            javaServer.status.setText("Offline");
  131	    }
  132	
  133	    /**
  134	     * broadcast data to all clients on server
  135	     * @param string data to send
  136	     */
  137	    public static void broadcastMessage(String string) {
  138	        System.out.println("broadcasting... "+string);
  139	        synchronized (clients) {
  140	            for(int i=0;i<clients.size();i++)
  141	                if(clients.get(i) != null)
  142	                    clients.get(i).sendMessage(string);
  143	        }
  144	    }
  145	
  146	    /** find a client given a string name
  147	     *
  148	     * @param name name of client
  149	     * @return id of client or -1 if not found
  150	     */
  151	    public static int findClientByName(String name) {
  152	        synchronized (clients) {
  153	            for(int i=0;i<clients.size();i++) {
  154	                if(clients.get(i) != null && clients.get(i).client.name.equalsIgnoreCase(name))
  155	                    return i;
  156	            }
  157	        }
  158	
  159	        return -1;
  160	    }
  161	    
  162	    public static String findUnusedName() {
  163	        String name = "";
  164	        int id = 0;
  165	        int foundAt;
  166	        synchronized (clients) {
  167	            do {
  168	                name = "User"+id;







2012-03-17 20:17 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaServer.java Page 4


  169	                foundAt = findClientByName(name);
  170	                id++;
  171	            } while(foundAt != -1);
  172	        }
  173	        return name;
  174	    }
  175	
  176	    /**
  177	     * finds a service by name, or creates a new one if none found
  178	     * @param name name of type of service
  179	     * @param empty if service must be empty
  180	     * @return the id of the server being searched for
  181	     */
  182	    public static int findServiceByName(String name, boolean empty) {
  183	        for(int i=0;i<services.size();i++) {
  184	            if(services.get(i) != null && services.get(i).name.equalsIgnoreCase(name))
  185	                if(!empty || services.get(i).clients.size() <= 1)
  186	                    return i;
  187	        }
  188	        
  189	        int serviceType = -1;
  190	        for(int i=0;i<Service.getNumServices();i++) {
  191	            if(Service.getGameType(i).equalsIgnoreCase(name))
  192	                serviceType = i;
  193	        }
  194	        
  195	        if(serviceType == -1)
  196	            return -1;
  197	
  198	        int serviceID = services.size();
  199	
  200	        Service service = null;
  201	        if(serviceType == 0)
  202	            service = new LobbyService(serviceID);
  203	        else if(serviceType == 1)
  204	            service = new TicTacToeService(serviceID);
  205	        else if(serviceType == 2)
  206	            service = new GomokuService(serviceID);
  207	        else if(serviceType == 3)
  208	            service = new ChessService(serviceID);
  209	
  210	        if(service == null)
  211	            return -1;
  212	
  213	        services.add(service);
  214	        broadcastMessage("NEW;"+serviceType);
  215	
  216	//        service.addClient(clients.get(0));
  217	        
  218	        return serviceID;
  219	    }
  220	
  221	    //chat convention
  222	
  223	    /** ban ip from server
  224	     *







2012-03-17 20:17 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaServer.java Page 5


  225	     * @param IP ip to ban
  226	     */
  227	    public static void banIP(String IP) {
  228	        for(int i=0;i<bannedList.size();i++) {
  229	            if(IP.equals(bannedList.get(i)))
  230	                return;
  231	        }
  232	        System.out.println("B&: "+IP);
  233	        bannedList.add(IP.split(":")[0]);
  234	    }
  235	
  236	    //chat convention
  237	
  238	    /**
  239	     * unban an IP
  240	     * @param IP ip to unban
  241	     */
  242	    public static void unbanIP(String IP) {
  243	        for(int i=0;i<bannedList.size();i++) {
  244	            if(IP.equals(bannedList.get(i))) {
  245	                bannedList.remove(i);
  246	                return;
  247	            }
  248	        }
  249	    }
  250	
  251	    //chat convention
  252	
  253	    /**
  254	     * is IP banned?
  255	     * @param IP ip in question
  256	     * @return if IP is banned
  257	     */
  258	    public static boolean isBanned(String IP) {
  259	        String ADDR = IP.split(":")[0];
  260	        for(int i=0;i<bannedList.size();i++) {
  261	            if(ADDR.equals(bannedList.get(i)))
  262	                return true;
  263	        }
  264	        return false;
  265	    }
  266	
  267	    /**
  268	     * a button to allow server to start or stop
  269	     */
  270	    class ConnectButton extends JButton implements ActionListener {
  271	        public ConnectButton() {
  272	            super("Start Server");
  273	            addActionListener(this);
  274	        }
  275	        
  276	        public void actionPerformed(ActionEvent ev) {
  277	            if(connected) {
  278	                setText("Start Server");
  279	                javaServer.stop();
  280	            } else {







2012-03-17 20:17 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaServer.java Page 6


  281	                setText("Stop Server");
  282	                javaServer.connect(Integer.parseInt(port_box.getText()));
  283	            }
  284	        }
  285	    }
  286	
  287	    /** thread to prevent gui from freezing on connect
  288	     *
  289	     */
  290	    class MainThread extends Thread implements Runnable {
  291	        public MainThread(int P) {
  292	            portNum = P;
  293	        }
  294	        
  295	        public void run() {
  296	            running = true;
  297	            clients = new ArrayList<ClientConnect>();
  298	            bannedList = new ArrayList<String>();
  299	
  300	            services = new ArrayList<Service>();
  301	            lobby = new LobbyService(0);
  302	            services.add(lobby);
  303	
  304	            //clients.add(new edu.ucsb.cs56.W12.jcolicchio.issue535.EchoConnect(clients.size()));
  305	            //clients.add(new edu.ucsb.cs56.W12.jcolicchio.issue535.ShoutConnect(clients.size()));
  306	            ServerSocket serverSock = null;
  307	            Socket sock = null;
  308	            System.out.println("total users: "+clients.size());
  309	            try {
  310	                connected = true;
  311	                serverSock = new ServerSocket(portNum);
  312	                
  313	                while(running) {
  314	                    //a new client wants to connect
  315	                    System.out.println("waiting for next connection...");
  316	                    updateServerGUI();
  317	                    sock = serverSock.accept();
  318	                    if(!running) {
  319	                        updateServerGUI();
  320	                        sock.close();
  321	                        break;
  322	                    }
  323	
  324	                    System.out.println("incoming connecting...");
  325	                    //give them a client object, run it in a thread
  326	                    ClientConnect conn = new ClientConnect(sock);
  327	                    Thread thread = new Thread(conn);
  328	                    thread.start();
  329	                    System.out.println("thread started");
  330	                }
  331	            } catch(IOException ex) {
  332	                if(!nogui) {
  333	                    javaServer.status.setText("Port already taken");
  334	                    javaServer.connectButton.setText("Start Server");
  335	                }
  336	                ex.printStackTrace();







2012-03-17 20:17 src/edu/ucsb/cs56/W12/jcolicchio/issue535/JavaServer.java Page 7


  337	                System.out.println("requested port already taken. quitting...");
  338	            }
  339	            try {
  340	                for(int i=0;i<clients.size();i++)
  341	                    if(clients.get(i) != null)
  342	                        clients.get(i).disconnect("Server stopping");
  343	                int left = 0;
  344	                do {
  345	                    left = 0;
  346	                    for(int i=0;i<clients.size();i++) {
  347	                        if(clients.get(i) != null)
  348	                            left++;
  349	                    }
  350	                    Thread.sleep(50);
  351	                } while(left > 0);
  352	                serverSock.close();
  353	            } catch(Exception ex) {
  354	                ex.printStackTrace();
  355	            }
  356	            connected = false;
  357	        }
  358	    }
  359	}
  360	
  361	
  362	//server update thread goes here





































2012-03-17 15:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/LobbyPanel.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import javax.swing.*;
    4	import java.awt.*;
    5	import java.awt.event.ActionEvent;
    6	import java.awt.event.ActionListener;
    7	import java.awt.event.MouseEvent;
    8	
    9	/**
   10	 * The lobby panel is a panel which displays currently available games which, when clicked on, will take the user to a
   11	 * new or in-progress copy of that game. Soon, buttons will take players to instruction screens where they can choose
   12	 * a few settings and specify if they want any server, or specifically an empty one to start a new game
   13	 *
   14	 * @author Joseph Colicchio
   15	 * @version for CS56, Choice Points, Winter 2012
   16	 */
   17	
   18	public class LobbyPanel extends GamePanel {
   19	    public LobbyPanel() {
   20	        setLayout(new FlowLayout());
   21	        JoinGameButton ticTacToeButton = new JoinGameButton("TicTacToe");
   22	        add(BorderLayout.NORTH, ticTacToeButton);
   23	        JoinGameButton gomokuButton = new JoinGameButton("Gomoku");
   24	        add(BorderLayout.NORTH, gomokuButton);
   25	        JoinGameButton chessButton = new JoinGameButton("Chess");
   26	        add(BorderLayout.NORTH, chessButton);
   27	    }
   28	
   29	    public void paintComponent(Graphics g) {
   30	        g.setColor(Color.white);
   31	        g.fillRect(0, 0, getWidth(), getHeight());
   32	    }
   33	
   34	    @Override
   35	    public void mouseClicked(MouseEvent mouseEvent){
   36	        System.out.println("HI");
   37	//            sendMessage("MSG;/join TicTacToe");
   38	        //To change body of implemented methods use File | Settings | File Templates.
   39	    }
   40	
   41	    @Override
   42	    public void mousePressed(MouseEvent mouseEvent){
   43	        //To change body of implemented methods use File | Settings | File Templates.
   44	    }
   45	
   46	    @Override
   47	    public void mouseReleased(MouseEvent mouseEvent){
   48	        //To change body of implemented methods use File | Settings | File Templates.
   49	    }
   50	
   51	    @Override
   52	    public void mouseEntered(MouseEvent mouseEvent){
   53	        //To change body of implemented methods use File | Settings | File Templates.
   54	    }
   55	
   56	    @Override







2012-03-17 15:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/LobbyPanel.java Page 2


   57	    public void mouseExited(MouseEvent mouseEvent){
   58	        //To change body of implemented methods use File | Settings | File Templates.
   59	    }
   60	
   61	    class JoinGameButton extends JButton implements ActionListener{
   62	        String name;
   63	        public JoinGameButton(String text) {
   64	            super(text);
   65	            name = text;
   66	            this.addActionListener(this);
   67	        }
   68	        @Override
   69	        public void actionPerformed(ActionEvent actionEvent){
   70	            JavaClient.javaClient.sendMessage("MSG;/join " + name);
   71	        }
   72	    }
   73	}














































2012-03-17 15:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/LobbyService.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;//Lobbyservice is a service that newly connecting players join by default
    2	//it
    3	
    4	import java.util.ArrayList;
    5	/**
    6	 * Since all clients need an "active service" to be connected to, which listens to input, lobby service is a service that
    7	 * extends chat service and does little else. quite honestly, it doesn't do much else besides extend chatservice, so
    8	 * its existence is largely pointless
    9	 *
   10	 * @author Joseph Colicchio
   11	 * @version for CS56, Choice Points, Winter 2012
   12	 */
   13	
   14	public class LobbyService extends ChatService {
   15	    public LobbyService(int ID) {
   16	        id = ID;
   17	        type = 0;
   18	        clients = new ArrayList<ClientConnect>();
   19	        name = "Lobby";
   20	    }
   21	    
   22	    @Override
   23	    public void handleData(ClientConnect client, String data) {
   24	        System.out.println("lobby "+id+" handled it");
   25	        super.handleData(client, data);
   26	        //for now, treat chat messages like client commands
   27	    }
   28	}



































2012-03-17 16:43 src/edu/ucsb/cs56/W12/jcolicchio/issue535/Message.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * A message object for use in javaclient, rendering message history
    5	 * keeps track of user, makes it easy to determine if the text should be bold or italicised, stores more data than a string could
    6	 *
    7	 * @author Joseph Colicchio
    8	 * @version for CS56, Choice Points, Winter 2012
    9	 */
   10	
   11	public class Message{
   12	    String message;
   13	    String author;
   14	    boolean privateMessage;
   15	    boolean outgoing;
   16	    int style;
   17	    
   18	    //message: the actual message content
   19	    //from: the sender of the message
   20	    //to: if it's private, where it went
   21	    //privateMessage: if the message was sent privately
   22	    //style: 0=plain, 1=bold, 2=italics, 3=both
   23	
   24	    /**
   25	     * constructor
   26	     * @param MSG message to print
   27	     * @param AUTHOR author of message
   28	     * @param PRIVATE if message is private
   29	     * @param OUTGOING if message was private, is it outgoing or incoming
   30	     */
   31	    public Message(String MSG, String AUTHOR, boolean PRIVATE, boolean OUTGOING) {
   32	        message = MSG;
   33	        author = AUTHOR;
   34	        privateMessage = PRIVATE;
   35	        outgoing = OUTGOING;
   36	        style = 0;
   37	
   38	        //if it's a private message, make it bold
   39	        //if it's a /me, make it italic
   40	        if(privateMessage)
   41	            style=1;
   42	        else if(message.indexOf("/me ") == 0)
   43	            style=2;
   44	    }
   45	    
   46	    @Override
   47	    public String toString() {
   48	        String string = "";
   49	        if(style == 2)
   50	            string += "<i>";
   51	        if(privateMessage) {
   52	            string += "<b>";
   53	            if(outgoing)
   54	                string += "(to "+author+")";
   55	            else
   56	                string += "(from "+author+")";







2012-03-17 16:43 src/edu/ucsb/cs56/W12/jcolicchio/issue535/Message.java Page 2


   57	        } else {
   58	            string += author;
   59	        }
   60	        if(style == 2)
   61	            string += " "+message.substring(4)+"</i>";
   62	        else
   63	            string += ": "+message;
   64	        if(privateMessage)
   65	            string += "</b>";
   66	        return string;
   67	    }
   68	}



















































2012-03-17 15:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/OfflinePanel.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import javax.swing.*;
    4	import java.awt.*;
    5	import java.awt.event.ActionEvent;
    6	import java.awt.event.ActionListener;
    7	import java.awt.event.MouseEvent;
    8	
    9	/**
   10	 * offline panel provides two textfields for IP address and port, and a connect button
   11	 * if the ip and port combination are invalid, it'll stall for a few seconds while it times out
   12	 * in the future, i'd like to have a thread do this, so the gui doesn't freeze with the connect button clicked
   13	 *
   14	 * @author Joseph Colicchio
   15	 * @version for CS56, Choice Points, Winter 2012
   16	 */
   17	
   18	//TODO: make new thread when connect is clicked, which is resolved as soon as the connection is made, but does not freeze the gui while waiting
   19	public class OfflinePanel extends GamePanel {
   20	    JTextField ip_box;
   21	    JTextField port_box;
   22	    ConnectButton connectButton;
   23	    
   24	    public OfflinePanel(String IP, int PORT) {
   25	        setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
   26	        ip_box = new JTextField("127.0.0.1");
   27	        ip_box.setPreferredSize(new Dimension(100,22));
   28	        ip_box.setAlignmentY(JTextField.CENTER_ALIGNMENT);
   29	        ip_box.setText(IP);
   30	        port_box = new JTextField("12345");
   31	        port_box.setPreferredSize(new Dimension(45,22));
   32	        port_box.setAlignmentY(JTextField.CENTER_ALIGNMENT);
   33	        port_box.setText(PORT+"");
   34	        connectButton = new ConnectButton();
   35	        connectButton.setAlignmentY(JButton.CENTER_ALIGNMENT);
   36	        JPanel connect_panel = new JPanel();
   37	        connect_panel.add(ip_box);
   38	        connect_panel.add(port_box);
   39	        connect_panel.add(connectButton);
   40	        add(Box.createVerticalGlue());
   41	        add(connect_panel);
   42	        ip_box.requestFocus();
   43	    }
   44	
   45	    @Override
   46	    public void mouseClicked(MouseEvent mouseEvent){}
   47	
   48	    @Override
   49	    public void mousePressed(MouseEvent mouseEvent){}
   50	
   51	    @Override
   52	    public void mouseReleased(MouseEvent mouseEvent){}
   53	
   54	    @Override
   55	    public void mouseEntered(MouseEvent mouseEvent){}
   56	







2012-03-17 15:31 src/edu/ucsb/cs56/W12/jcolicchio/issue535/OfflinePanel.java Page 2


   57	    @Override
   58	    public void mouseExited(MouseEvent mouseEvent){}
   59	
   60	    public class ConnectButton extends JButton implements ActionListener{
   61	        public ConnectButton() {
   62	            super("Connect");
   63	            addActionListener(this);
   64	        }
   65	
   66	        public void actionPerformed(ActionEvent ev) {
   67	            JavaClient.javaClient.connect(ip_box.getText(),Integer.parseInt(port_box.getText()));
   68	        }
   69	    }
   70	}

















































2012-03-17 04:51 src/edu/ucsb/cs56/W12/jcolicchio/issue535/Res.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import javax.imageio.ImageIO;
    4	import java.io.IOException;
    5	import java.awt.*;
    6	
    7	/**
    8	 * stores resources for recycling
    9	 * currently, just has chess pieces image, but will soon have more images and sounds for audio notification
   10	 *
   11	 * @author Joseph Colicchio
   12	 * @version for CS56, Choice Points, Winter 2012
   13	 */
   14	
   15	public class Res {
   16	    public static Image ChessPieces;
   17	
   18	    public Res() {
   19	
   20	    }
   21	
   22	    public static void init(Class frame) {
   23	        ChessPieces = null;
   24	        try {
   25	            ChessPieces = ImageIO.read(frame.getResource("/graphics/pieces.png"));
   26	
   27	        } catch (IOException e) {
   28	            System.out.println("oops");
   29	        }
   30	    }
   31	}
































2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ServerConnect.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * server connect was a specific dummy user that joined every service when it was made, and allowed the server to "speak"
    5	 * by sending messages from id 0, which was always server
    6	 * since i added a new standard of communication, SMSG, for specifically that purpose, the serverconnect class is largely
    7	 * useless, and is not used at all in javaserver
    8	 *
    9	 * @author Joseph Colicchio
   10	 * @version for CS56, Choice Points, Winter 2012
   11	 */
   12	
   13	public class ServerConnect extends ClientConnect {
   14	    public ServerConnect(int id) {
   15	        super(null);
   16	        client = new ClientObject(id, "Server", 0);
   17	        System.out.println("server has client: "+client.name);
   18	    }
   19	
   20	    @Override
   21	    public void sendMessage(String string) {
   22	        //System.out.println("server got msg: "+string);
   23	        if(string.indexOf("PMSG[") == 0) {
   24	            String[] data = string.substring(5).split("]");
   25	            int id = Integer.parseInt(data[0]);
   26	            String msg = string.substring(5+data[0].length()+1);
   27	            System.out.println("server wanted to say this: ");
   28	            //edu.ucsb.cs56.W12.jcolicchio.issue535.JavaServer.clients.get(id).sendMessage("PMSG[0]Echo You said "+msg);
   29	        }
   30	    }
   31	}
































2012-03-17 16:46 src/edu/ucsb/cs56/W12/jcolicchio/issue535/Service.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import java.util.ArrayList;
    4	
    5	/**
    6	 * Service is an abstract class to be extended by all services
    7	 * a service is the server-side connection between a client and the server's copy of a game,
    8	 * passing data from the client to the game, as delegated by the clientconnect object on the server
    9	 *
   10	 * @author Joseph Colicchio
   11	 * @version for CS56, Choice Points, Winter 2012
   12	 */
   13	
   14	public abstract class Service{
   15	    private static ArrayList<String> serviceList;
   16	    private static int numServices;
   17	    public ArrayList<ClientConnect> clients;
   18	    public String name;
   19	    public int id;
   20	    public int type;
   21	    private static boolean _init;
   22	
   23	    public static void initData() {
   24	        _init = true;
   25	
   26	        serviceList = new ArrayList<String>();
   27	        serviceList.add("Lobby");
   28	        serviceList.add("TicTacToe");
   29	        serviceList.add("Gomoku");
   30	        serviceList.add("Chess");
   31	        numServices = serviceList.size();
   32	    }
   33	
   34	    /**
   35	     * get the number of unique services
   36	     * @return number of unique services
   37	     */
   38	    public static int getNumServices() {
   39	        if(!_init)
   40	            initData();
   41	        return numServices;
   42	    }
   43	
   44	    /**
   45	     * get the type of service by its listed type number
   46	     * @param n the type number of a service
   47	     * @return name of a kind of service
   48	     */
   49	    public static String getGameType(int n) {
   50	        if(!_init)
   51	            initData();
   52	        if(n < 0 || n >= serviceList.size())
   53	            return null;
   54	
   55	        return serviceList.get(n);
   56	    }







2012-03-17 16:46 src/edu/ucsb/cs56/W12/jcolicchio/issue535/Service.java Page 2


   57	
   58	    /**
   59	     * add a client to this service
   60	     * @param client client to add
   61	     */
   62	    public abstract void addClient(ClientConnect client);
   63	
   64	    /**
   65	     * remove a client from this service
   66	     * @param client client to remove
   67	     */
   68	    public abstract void removeClient(ClientConnect client);
   69	
   70	    /**
   71	     * send data to all clients on service
   72	     * @param data data to send
   73	     */
   74	    public abstract void broadcastData(String data);
   75	
   76	    /**
   77	     * handle incoming data from a client
   78	     * @param client client sending the data
   79	     * @param data data to handle
   80	     */
   81	    public abstract void handleData(ClientConnect client, String data);
   82	
   83	    /**
   84	     * switch a client from one service to another
   85	     * @param client client to switch
   86	     * @param service service to switch to
   87	     */
   88	    public abstract void switchServices(ClientConnect client, Service service);
   89	}






























2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/ShoutConnect.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * Shout connect is a dummy client that listens for private messages and repeats them publically
    5	 * commands like /nick, /join, etc are displayed as raw text to prevent abuse or griefing by users
    6	 *
    7	 * @author Joseph Colicchio
    8	 * @version for CS56, Choice Points, Winter 2012
    9	 */
   10	
   11	public class ShoutConnect extends ClientConnect {
   12	    public ShoutConnect(int id) {
   13	        super(null);
   14	        client = new ClientObject(id,"SHOUT",0);
   15	    }
   16	
   17	    @Override
   18	    public void sendMessage(String string) {
   19	        //System.out.println("shout got msg: "+string);
   20	        if(string.indexOf("PMSG[") == 0) {
   21	            String[] data = string.substring(5).split("]");
   22	            int id = Integer.parseInt(data[0]);
   23	            if(id == client.id)
   24	                return;
   25	            String msg = string.substring(5+data[0].length()+1);
   26	            //handleMessage("MSG;"+string.substring(5+data[0].length()+1));
   27	            System.out.println("shout said this: " + string.substring(5 + data[0].length() + 1));
   28	//            if(string.substring(5+data[0].length()+1).indexOf("/me ") == 0)
   29	            JavaServer.broadcastMessage("MSG["+client.id+"]"+string.substring(5+data[0].length()+1));
   30	//            else
   31	//                edu.ucsb.cs56.W12.jcolicchio.issue535.JavaServer.broadcastMessage("MSG[2]"+string.substring(5+data[0].length()+1));
   32	        }
   33	    }
   34	}





























2012-03-17 04:55 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToeGame.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * tictactoegame is a tic tac toe game object that stores data about a tic tac toe game, such as placement of Xs and Os,
    5	 * and possibly the winner
    6	 *
    7	 * @author Joseph Colicchio
    8	 * @version for CS56, Choice Points, Winter 2012
    9	 */
   10	
   11	public class TicTacToeGame{
   12	    public ClientObject player1, player2;
   13	    
   14	    public int[][] grid;
   15	    public int turn;
   16	    public int winner;
   17	
   18	    public TicTacToeGame() {
   19	        init();
   20	    }
   21	
   22	    public void init() {
   23	        grid = new int[3][3];
   24	        for(int i=0;i<3;i++)
   25	            for(int j=0;j<3;j++)
   26	                grid[i][j] = 0;
   27	
   28	        turn = 1;
   29	        winner = 0;
   30	    }
   31	
   32	    public boolean checkWinner() {
   33	        for(int j=1;j<3;j++) {
   34	            for(int i=0;i<3;i++) {
   35	                if(grid[0][i] == j && grid[1][i] == j && grid[2][i] == j) {
   36	                    winner = j;
   37	                    return true;
   38	                }
   39	                if(grid[i][0] == j && grid[i][1] == j && grid[i][2] == j) {
   40	                    winner = j;
   41	                    return true;
   42	                }
   43	            }
   44	            if(grid[0][0] == j && grid[1][1] == j && grid[2][2] == j) {
   45	                winner = j;
   46	                return true;
   47	            }
   48	            if(grid[0][2] == j && grid[1][1] == j && grid[2][0] == j) {
   49	                winner = j;
   50	                return true;
   51	            }
   52	        }
   53	        System.out.println("no winner found");
   54	        return false;
   55	    }
   56	    







2012-03-17 04:55 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToeGame.java Page 2


   57	    public void setState(String data) {
   58	        String[] info = data.substring(6).split("]");
   59	        int turnInfo = Integer.parseInt(info[0]);
   60	        if(turnInfo == 0)
   61	            checkWinner();
   62	        else {
   63	            turn = turnInfo;
   64	            winner = 0;
   65	        }
   66	        String[] rows = info[1].split(";");
   67	        for(int i=0;i<3;i++) {
   68	            String[] cols = rows[i].split(",");
   69	            for(int j=0;j<3;j++) {
   70	                grid[i][j] = Integer.parseInt(cols[j]);
   71	            }
   72	        }
   73	        checkWinner();
   74	    }
   75	    
   76	    public String getState() {
   77	        String state = "STATE[";
   78	        if(winner == 0)
   79	            state += turn+"]";
   80	        else
   81	            state += "0]";
   82	        for(int i=0;i<3;i++) {
   83	            for(int j=0;j<3;j++) {
   84	                state += grid[i][j];
   85	                if(j < 2)
   86	                    state +=",";
   87	            }
   88	            if(i<2)
   89	                state += ";";
   90	        }
   91	        return state;
   92	    }
   93	}


























2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToePanel.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import javax.swing.*;
    4	import java.awt.*;
    5	import java.awt.event.ActionEvent;
    6	import java.awt.event.ActionListener;
    7	import java.awt.event.MouseEvent;
    8	import java.awt.event.MouseListener;
    9	import java.awt.geom.GeneralPath;
   10	
   11	
   12	/**
   13	 * tictactoepanel allows user to interface with server while playing tic tac toe game, accepts input and draws board and
   14	 * current player's turn on the screen
   15	 *
   16	 * @author Joseph Colicchio
   17	 * @version for CS56, Choice Points, Winter 2012
   18	 */
   19	
   20	public class TicTacToePanel extends GamePanel {
   21	    TicTacToeGame game;
   22	    JPanel menuButtons;
   23	
   24	    JButton playSpecButton;
   25	    LeaveButton leaveButton;
   26	    NewGameButton newGameButton;
   27	
   28	    public boolean isPlaying;
   29	    
   30	    int offsetX, offsetY;
   31	    int margin = 3;
   32	    int gridSize;
   33	    int panelSize;
   34	    int topMargin = 40;
   35	    int bottomMargin = 30;
   36	
   37	    public TicTacToePanel() {
   38	        setLayout(new BorderLayout());
   39	        menuButtons = new JPanel();
   40	//        menuButtons.setLayout(new BoxLayout(menuButtons, BoxLayout.X_AXIS));
   41	        add(BorderLayout.SOUTH, menuButtons);
   42	        playSpecButton = new PlaySpecButton();
   43	        playSpecButton.setAlignmentX(CENTER_ALIGNMENT);
   44	        leaveButton = new LeaveButton();
   45	        leaveButton.setAlignmentX(CENTER_ALIGNMENT);
   46	        newGameButton = new NewGameButton();
   47	        newGameButton.setAlignmentX(CENTER_ALIGNMENT);
   48	        newGameButton.setEnabled(false);
   49	        menuButtons.add(playSpecButton);
   50	        menuButtons.add(leaveButton);
   51	        menuButtons.add(newGameButton);
   52	
   53	        game = new TicTacToeGame();
   54	        
   55	        TicTacToeCanvas canvas = new TicTacToeCanvas();
   56	        canvas.addMouseListener(canvas);







2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToePanel.java Page 2


   57	        add(BorderLayout.CENTER, canvas);
   58	        
   59	        isPlaying = false;
   60	    }
   61	
   62	    @Override
   63	    public void handleMessage(String string) {
   64	        System.out.println("handling as tictactoe: "+string);
   65	        if(string.indexOf("INIT;") == 0) {
   66	            game.init();
   67	        } else if(string.indexOf("STATE[") == 0) {
   68	            game.setState(string);
   69	        } else if(string.indexOf("MOVE[") == 0) {
   70	            String[] data = string.substring(5).split("]");
   71	            int pid = Integer.parseInt(data[0]);
   72	            String[] coords = data[1].split(",");
   73	            int X = Integer.parseInt(coords[0]);
   74	            int Y = Integer.parseInt(coords[1]);
   75	
   76	            game.grid[Y][X] = pid;
   77	            game.turn = 3-pid;
   78	        } else if(string.indexOf("PLAYERS;") == 0) {
   79	            String[] data = string.substring(8).split(",");
   80	            int pid1 = Integer.parseInt(data[0]);
   81	            int pid2 = Integer.parseInt(data[1]);
   82	            System.out.println(pid1+", "+JavaClient.javaClient.clients.size());
   83	            if(pid1 >= 0 && pid1 < JavaClient.javaClient.clients.size()) {
   84	                game.player1 = JavaClient.javaClient.clients.get(Integer.parseInt(data[0]));
   85	            } else
   86	                game.player1 = null;
   87	            if(pid2 >= 0 && pid2 < JavaClient.javaClient.clients.size())
   88	                game.player2 = JavaClient.javaClient.clients.get(Integer.parseInt(data[1]));
   89	            else
   90	                game.player2 = null;
   91	            
   92	            if(pid1 == JavaClient.javaClient.id || pid2 == JavaClient.javaClient.id) {
   93	                isPlaying = true;
   94	                if(game.player1 != null && game.player2 != null)
   95	                    newGameButton.setEnabled(true);
   96	                else
   97	                    newGameButton.setEnabled(false);
   98	            } else {
   99	                isPlaying = false;
  100	                newGameButton.setEnabled(false);
  101	            }
  102	            
  103	            if(isPlaying || game.player1 == null || game.player2 == null)
  104	                playSpecButton.setEnabled(true);
  105	            else
  106	                playSpecButton.setEnabled(false);
  107	        } else if(string.indexOf("WINNER;")==0) {
  108	            game.winner = Integer.parseInt(string.substring(7));
  109	        }
  110	    }
  111	    
  112	    class TicTacToeCanvas extends JPanel implements MouseListener {







2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToePanel.java Page 3


  113	
  114	        @Override
  115	        public void paintComponent(Graphics g) {
  116	            super.paintComponent(g);
  117	
  118	            int totalWidth = getWidth();
  119	            int totalHeight = getHeight();
  120	
  121	            int gridHeight = totalHeight - topMargin - bottomMargin;
  122	            int gridWidth = totalWidth;
  123	            if(gridHeight < gridWidth) {
  124	                panelSize = gridHeight;
  125	                offsetX = (totalWidth-panelSize)/2;
  126	                offsetY = topMargin;
  127	            } else {
  128	                panelSize = gridWidth;
  129	                offsetX = 0;
  130	                offsetY = (gridHeight-panelSize)/2+topMargin;
  131	            }
  132	
  133	            gridSize = panelSize/3;
  134	
  135	            g.setColor(Color.white);
  136	            g.fillRect(0,0,getWidth(),getHeight());
  137	            if(!JavaClient.javaClient.connected || JavaClient.javaClient.clients == null)
  138	                return;
  139	
  140	            g.setColor(new Color(0x333333));
  141	            g.fillRect(offsetX+gridSize-margin,offsetY, margin*2, gridSize*3);
  142	            g.fillRect(offsetX+gridSize*2-margin,offsetY, margin*2, gridSize*3);
  143	            g.fillRect(offsetX,offsetY+gridSize-margin, gridSize*3, margin*2);
  144	            g.fillRect(offsetX,offsetY+gridSize*2-margin, gridSize*3, margin*2);
  145	
  146	
  147	            Graphics2D g2d = (Graphics2D)g;
  148	            g2d.setStroke(new BasicStroke(5));
  149	            
  150	            for(int i=0;i<3;i++) {
  151	                for(int j=0;j<3;j++) {
  152	                    int pid = game.grid[i][j];
  153	                    if(pid == 0)
  154	                        continue;
  155	
  156	                    if(pid == 1) {
  157	                        g2d.setColor(Color.RED);
  158	                        GeneralPath path = new GeneralPath();
  159	                        path.moveTo(offsetX + j * gridSize + 3*margin, offsetY + i * gridSize + 3*margin);
  160	                        path.lineTo(offsetX+(j+1)*gridSize - 3*margin, offsetY+(i+1)*gridSize - 3*margin);
  161	                        path.moveTo(offsetX+(j+1)*gridSize - 3*margin, offsetY + i * gridSize + 3*margin);
  162	                        path.lineTo(offsetX + j * gridSize + 3*margin, offsetY+(i+1)*gridSize - 3*margin);
  163	                        g2d.draw(path);
  164	                    } else {
  165	                        g.setColor(Color.BLUE);
  166	                        g.drawOval( offsetX + j * gridSize + 3*margin, offsetY + i * gridSize + 3*margin,
  167	                                gridSize - 6*margin, gridSize - 6*margin);
  168	                    }







2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToePanel.java Page 4


  169	
  170	                }
  171	            }
  172	
  173	            g2d.setStroke(new BasicStroke(2));
  174	            String readyState = "";
  175	            if(game.player1 != null) {
  176	                g.setColor(Color.red);
  177	                g.drawString("Player 1: " + game.player1.name, offsetX, 15);
  178	                GeneralPath path = new GeneralPath();
  179	                path.moveTo(offsetX-23,offsetY-38);
  180	                path.lineTo(offsetX-7, offsetY-22);
  181	                path.moveTo(offsetX-7,offsetY-38);
  182	                path.lineTo(offsetX-23, offsetY-22);
  183	                g2d.draw(path);
  184	            } else
  185	                readyState = "waiting for players";
  186	            if(game.player2 != null) {
  187	                g.setColor(Color.blue);
  188	                g.drawString("Player 2: "+game.player2.name,offsetX,35);
  189	                g.drawOval( offsetX -23, offsetY - 18,
  190	                        16, 16);
  191	            } else
  192	                readyState = "waiting for players";
  193	
  194	            if(readyState.equals("")) {
  195	                if(game.winner == 1)
  196	                    readyState = game.player1.name+" wins!";
  197	                else if(game.winner == 2)
  198	                    readyState = game.player2.name+" wins!";
  199	                else if(game.turn == 1)
  200	                    readyState = game.player1.name+"'s turn";
  201	                else
  202	                    readyState = game.player2.name+"'s turn";
  203	            }
  204	
  205	            g.setColor(new Color(0x222222));
  206	            g.drawString(readyState,offsetX+panelSize/2-45,offsetY+panelSize+20);
  207	        }
  208	        @Override
  209	        public void mouseClicked(MouseEvent mouseEvent){ }
  210	        @Override
  211	        public void mousePressed(MouseEvent mouseEvent){
  212	            if(!isPlaying)
  213	                return;
  214	
  215	            //To change body of implemented methods use File | Settings | File Templates.
  216	            int mX = mouseEvent.getX();
  217	            int mY = mouseEvent.getY();
  218	            int dX = mX-offsetX;
  219	            int dY = mY-offsetY;
  220	            int cellX = (dX*3/panelSize);
  221	            int cellY = (dY*3/panelSize);
  222	            System.out.println(mX+", "+mY+", "+dX+", "+dY+", "+cellX+", "+cellY);
  223	            if(cellX >= 0 && cellX < 3 && cellY >= 0 && cellY < 3) {
  224	                JavaClient.javaClient.sendMessage("MOVE;" + cellX + "," + cellY);







2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToePanel.java Page 5


  225	            }
  226	        }
  227	        @Override
  228	        public void mouseReleased(MouseEvent mouseEvent){ }
  229	        @Override
  230	        public void mouseEntered(MouseEvent mouseEvent){ }
  231	        @Override
  232	        public void mouseExited(MouseEvent mouseEvent){ }
  233	    }
  234	
  235	    class PlaySpecButton extends JButton implements ActionListener{
  236	        public boolean playing;
  237	        public PlaySpecButton() {
  238	            super("Play");
  239	            playing = false;
  240	            addActionListener(this);
  241	        }
  242	
  243	        @Override
  244	        public void actionPerformed(ActionEvent actionEvent){
  245	            if(playing) {
  246	                JavaClient.javaClient.sendMessage("MSG;/spec");
  247	                setText("Play");
  248	                playing = false;
  249	            } else {
  250	                JavaClient.javaClient.sendMessage("MSG;/play");
  251	                setText("Spectate");
  252	                playing = true;
  253	            }
  254	        }
  255	    }
  256	    class LeaveButton extends JButton implements ActionListener{
  257	        public LeaveButton() {
  258	            super("Leave");
  259	            addActionListener(this);
  260	        }
  261	
  262	        @Override
  263	        public void actionPerformed(ActionEvent actionEvent){
  264	            JavaClient.javaClient.sendMessage("MSG;/join lobby");
  265	        }
  266	    }
  267	    class NewGameButton extends JButton implements ActionListener {
  268	        public NewGameButton() {
  269	            super("New Game");
  270	            addActionListener(this);
  271	        }
  272	
  273	        @Override
  274	        public void actionPerformed(ActionEvent actionEvent) {
  275	            JavaClient.javaClient.sendMessage("MSG;/newgame");
  276	        }
  277	    }
  278	}









2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToeService.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * gictactoeservice allows clientconnect to communicate with tictactoe game
    5	 *
    6	 * @author Joseph Colicchio
    7	 * @version for CS56, Choice Points, Winter 2012
    8	 */
    9	
   10	public class TicTacToeService extends TwoPlayerGameService {
   11	    public TicTacToeGame gameData;
   12	
   13	    public ClientConnect player1;
   14	    public ClientConnect player2;
   15	
   16	    public boolean gameStarted;
   17	
   18	    public TicTacToeService(int ID) {
   19	        super(ID);
   20	        gameData = new TicTacToeGame();
   21	        type = 1;
   22	        name = "TicTacToe";
   23	    }
   24	    
   25	    public void init() {
   26	        gameData.init();
   27	        broadcastData("INIT;");
   28	    }
   29	
   30	    public void playClient(ClientConnect client) {
   31	        if(player1 == null) {
   32	            player1 = client;
   33	            gameData.player1 = client.client;
   34	        } else if(player2 == null && player1 != client) {
   35	            player2 = client;
   36	            gameData.player2 = client.client;
   37	            gameStarted = true;
   38	            System.out.println("ready to play: "+player1.client.id+" vs "+player2.client.id);
   39	            gameData.init();
   40	        }
   41	
   42	        updateAll();
   43	    }
   44	
   45	    //if a client was a player, spec him, and then probably stop the game
   46	    public void specClient(ClientConnect client) {
   47	        if(player1 != client && player2 != client)
   48	            return;
   49	        if(player1 == client) {
   50	            player1 = player2;
   51	            gameData.player1 = gameData.player2;
   52	            player2 = null;
   53	            gameData.player2 = null;
   54	            gameStarted = false;
   55	            gameData.init();
   56	        }







2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToeService.java Page 2


   57	        if(player2 == client) {
   58	            player2 = null;
   59	            gameData.player2 = null;
   60	            gameStarted = false;
   61	            gameData.init();
   62	        }
   63	
   64	        updateAll();
   65	    }
   66	
   67	    //get move from player, if it's their turn
   68	    public void handleData(ClientConnect client, String string) {
   69	        if(string.indexOf("PLAY;") == 0)
   70	            playClient(client);
   71	        else if(string.indexOf("SPEC;") == 0)
   72	            specClient(client);
   73	        else if(string.indexOf("MSG;") == 0) {
   74	            String message = string.substring(4);
   75	            if(message.indexOf("/play")==0) {
   76	                playClient(client);
   77	            } else if(message.indexOf("/spec") == 0) {
   78	                specClient(client);
   79	            } else if(message.indexOf("/newgame") == 0) {
   80	                if(client == player1 || client == player2)
   81	                    init();
   82	            } else
   83	                super.handleData(client, string);
   84	        }
   85	
   86	        if(!gameStarted)
   87	            return;
   88	        System.out.println(gameData.turn+", "+client.client.id+", "+player1.client.id+":"+player2.client.id);
   89	        if(gameData.turn == 1 && client != player1)
   90	            return;
   91	        if(gameData.turn == 2 && client != player2)
   92	            return;
   93	        if(string.indexOf("MOVE;") == 0) {
   94	            if(gameData.winner != 0)
   95	                return;
   96	            System.out.println("got move command from "+client.client.id+": "+string);
   97	            String[] data = string.substring(5).split(",");
   98	            int X = Integer.parseInt(data[0]);
   99	            int Y = Integer.parseInt(data[1]);
  100	
  101	            if(gameData.grid[Y][X] != 0)
  102	                return;
  103	
  104	            gameData.grid[Y][X] = gameData.turn;
  105	            broadcastData("MOVE[" + gameData.turn + "]" + X + "," + Y);
  106	            if(gameData.checkWinner())
  107	                broadcastData("WINNER;"+gameData.winner);
  108	            gameData.turn = 3-gameData.turn;
  109	        }
  110	    }
  111	
  112	    //this could be done better, just broadcast gameData.getGameState and have that function generate this:







2012-03-17 15:32 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TicTacToeService.java Page 3


  113	    //wait but that isnt possible
  114	    //sends the state of the game to a player
  115	    public void sendGameState(ClientConnect client) {
  116	        if(client == null)
  117	            return;
  118	        synchronized (client) {
  119	            client.sendMessage(gameData.getState());
  120	            String players = "PLAYERS;";
  121	            if(gameData.player1 != null)
  122	                players += gameData.player1.id;
  123	            else
  124	                players += "-1";
  125	            players += ",";
  126	            if(gameData.player2 != null)
  127	                players += gameData.player2.id;
  128	            else
  129	                players += "-1";
  130	
  131	            client.sendMessage(players);
  132	        }
  133	    }
  134	}









































2012-03-17 04:57 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TwoPlayerGameService.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	import java.util.ArrayList;
    4	
    5	/**
    6	 * an abstract service classification for games which have two players
    7	 * all two-player games should extend this
    8	 *
    9	 * @author Joseph Colicchio
   10	 * @version for CS56, Choice Points, Winter 2012
   11	 */
   12	
   13	public abstract class TwoPlayerGameService extends ChatService{
   14	    public ClientConnect player1;
   15	    public ClientConnect player2;
   16	    
   17	    public boolean gameStarted;
   18	    
   19	    public TwoPlayerGameService(int ID) {
   20	        clients = new ArrayList<ClientConnect>();
   21	        gameStarted = false;
   22	        id = ID;
   23	    }
   24	    
   25	    public abstract void init();
   26	    
   27	    public void updateAll() {
   28	        synchronized (clients) {
   29	            for(int i=0;i<clients.size();i++)
   30	                sendGameState(clients.get(i));
   31	        }
   32	    }
   33	
   34	    public void addClient(ClientConnect client) {
   35	        synchronized (clients) {
   36	            super.addClient(client);
   37	            sendGameState(client);
   38	        }
   39	    }
   40	
   41	    public abstract void playClient(ClientConnect client);
   42	
   43	    public abstract void specClient(ClientConnect client);
   44	
   45	    public void removeClient(ClientConnect client) {
   46	        specClient(client);
   47	        super.removeClient(client);
   48	    }
   49	    
   50	    public void broadcastDate(String data) {
   51	        synchronized (clients) {
   52	            for(int i=0;i<clients.size();i++)
   53	                clients.get(i).sendMessage(data);
   54	        }
   55	    }
   56	







2012-03-17 04:57 src/edu/ucsb/cs56/W12/jcolicchio/issue535/TwoPlayerGameService.java Page 2


   57	    public abstract void sendGameState(ClientConnect client);
   58	}





























































2012-03-17 04:58 src/edu/ucsb/cs56/W12/jcolicchio/issue535/Username.java Page 1


    1	package edu.ucsb.cs56.W12.jcolicchio.issue535;
    2	
    3	/**
    4	 * Username class stores information about a user, such as name, location, etc
    5	 * rendered by the user list in javaclient
    6	 *
    7	 * @author Joseph Colicchio
    8	 * @version for CS56, Choice Points, Winter 2012
    9	 */
   10	
   11	public class Username{
   12	    String name;
   13	    String location;
   14	    public int style;
   15	    
   16	    public Username(String NAME, String LOCATION, int STYLE) {
   17	        name = NAME;
   18	        location = LOCATION;
   19	        style = STYLE;
   20	    }
   21	    @Override
   22	    public String toString() {
   23	        if(location == null)
   24	            return name;
   25	        return name+location;
   26	    }
   27	}


































